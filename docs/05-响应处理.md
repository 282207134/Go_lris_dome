# 05 - 响应处理

## 响应处理概述

Iris 提供了丰富的响应处理功能，支持多种响应格式，包括 JSON、XML、HTML、文本、文件等。同时提供了状态码设置、响应头控制、流式传输等高级功能。

## 基本响应

### 1. 文本响应

```go
func textResponse(ctx iris.Context) {
    // 简单文本响应
    ctx.WriteString("Hello, World!")
    
    // 带状态码的文本响应
    ctx.StatusCode(iris.StatusOK)
    ctx.WriteString("操作成功")
}

func htmlResponse(ctx iris.Context) {
    // HTML 响应
    ctx.HTML("<h1>Hello, Iris!</h1>")
    
    // 带状态码的 HTML 响应
    ctx.StatusCode(iris.StatusCreated)
    ctx.HTML("<p>资源创建成功</p>")
}
```

### 2. JSON 响应

```go
func jsonResponse(ctx iris.Context) {
    // 简单 JSON 响应
    ctx.JSON(iris.Map{
        "message": "Hello, Iris!",
        "status":  "success",
    })
    
    // 结构体 JSON 响应
    type User struct {
        ID       int    `json:"id"`
        Username string `json:"username"`
        Email    string `json:"email"`
    }
    
    user := User{
        ID:       1,
        Username: "john_doe",
        Email:    "john@example.com",
    }
    
    ctx.JSON(user)
    
    // 带状态码的 JSON 响应
    ctx.StatusCode(iris.StatusCreated)
    ctx.JSON(iris.Map{
        "message": "用户创建成功",
        "data":    user,
    })
}
```

### 3. XML 响应

```go
func xmlResponse(ctx iris.Context) {
    // 结构体 XML 响应
    type User struct {
        XMLName xml.Name `xml:"user"`
        ID      int      `xml:"id"`
        Name    string   `xml:"name"`
        Email   string   `xml:"email"`
    }
    
    user := User{
        ID:    1,
        Name:  "John Doe",
        Email: "john@example.com",
    }
    
    ctx.XML(user)
    
    // 带 XML 声明的响应
    ctx.ContentType("application/xml; charset=utf-8")
    ctx.WriteString(`<?xml version="1.0" encoding="UTF-8"?>`)
    ctx.XML(user)
}
```

## 响应结构

### 1. 统一响应格式

```go
// 统一响应结构
type Response struct {
    Code    int         `json:"code"`    // 响应码
    Message string      `json:"message"` // 响应消息
    Data    interface{} `json:"data"`    // 响应数据
}

// 分页响应结构
type PageResponse struct {
    Code    int         `json:"code"`    // 响应码
    Message string      `json:"message"` // 响应消息
    Data    interface{} `json:"data"`    // 响应数据
    Page    PageInfo    `json:"page"`    // 分页信息
}

type PageInfo struct {
    Current   int   `json:"current"`    // 当前页
    PageSize  int   `json:"page_size"`  // 每页大小
    Total     int64 `json:"total"`      // 总记录数
    TotalPage int   `json:"total_page"` // 总页数
}

// 创建成功响应
func SuccessResponse(ctx iris.Context, data interface{}) {
    response := Response{
        Code:    200,
        Message: "操作成功",
        Data:    data,
    }
    ctx.JSON(response)
}

// 创建分页响应
func PageResponse(ctx iris.Context, data interface{}, page, pageSize int, total int64) {
    totalPage := int(total) / pageSize
    if int(total)%pageSize > 0 {
        totalPage++
    }
    
    response := PageResponse{
        Code:    200,
        Message: "获取数据成功",
        Data:    data,
        Page: PageInfo{
            Current:   page,
            PageSize:  pageSize,
            Total:     total,
            TotalPage: totalPage,
        },
    }
    ctx.JSON(response)
}

// 创建错误响应
func ErrorResponse(ctx iris.Context, code int, message string) {
    response := Response{
        Code:    code,
        Message: message,
        Data:    nil,
    }
    ctx.StatusCode(code)
    ctx.JSON(response)
}

// 使用示例
func getUserList(ctx iris.Context) {
    page, _ := ctx.URLParamInt("page")
    pageSize, _ := ctx.URLParamInt("page_size")
    
    if page <= 0 {
        page = 1
    }
    if pageSize <= 0 {
        pageSize = 10
    }
    
    // 获取用户数据
    users, total, err := getUserService().GetUsers(page, pageSize)
    if err != nil {
        ErrorResponse(ctx, iris.StatusInternalServerError, "获取用户列表失败")
        return
    }
    
    PageResponse(ctx, users, page, pageSize, total)
}
```

### 2. 错误响应格式

```go
// 详细错误响应
type ErrorResponse struct {
    Code      int                    `json:"code"`       // 错误码
    Message   string                 `json:"message"`    // 错误消息
    Errors    map[string]interface{} `json:"errors"`     // 详细错误信息
    Timestamp string                 `json:"timestamp"`  // 时间戳
    Path      string                 `json:"path"`       // 请求路径
    RequestID string                 `json:"request_id"` // 请求ID
}

// 创建详细错误响应
func DetailedErrorResponse(ctx iris.Context, code int, message string, errors map[string]interface{}) {
    response := ErrorResponse{
        Code:      code,
        Message:   message,
        Errors:    errors,
        Timestamp: time.Now().Format("2006-01-02 15:04:05"),
        Path:      ctx.Path(),
        RequestID: ctx.Values().GetStringDefault("request_id", ""),
    }
    ctx.StatusCode(code)
    ctx.JSON(response)
}

// 验证错误响应
func ValidationErrorResponse(ctx iris.Context, validationErrors map[string]string) {
    errors := make(map[string]interface{})
    for field, message := range validationErrors {
        errors[field] = message
    }
    
    DetailedErrorResponse(ctx, iris.StatusBadRequest, "数据验证失败", errors)
}
```

## 状态码处理

### 1. HTTP 状态码

```go
func statusCodes(ctx iris.Context) {
    // 2xx 成功状态码
    ctx.StatusCode(iris.StatusOK)           // 200 OK
    ctx.StatusCode(iris.StatusCreated)       // 201 Created
    ctx.StatusCode(iris.StatusAccepted)       // 202 Accepted
    ctx.StatusCode(iris.StatusNoContent)      // 204 No Content
    
    // 3xx 重定向状态码
    ctx.StatusCode(iris.StatusMovedPermanently) // 301 Moved Permanently
    ctx.StatusCode(iris.StatusFound)            // 302 Found
    ctx.StatusCode(iris.StatusNotModified)      // 304 Not Modified
    
    // 4xx 客户端错误状态码
    ctx.StatusCode(iris.StatusBadRequest)      // 400 Bad Request
    ctx.StatusCode(iris.StatusUnauthorized)     // 401 Unauthorized
    ctx.StatusCode(iris.StatusForbidden)        // 403 Forbidden
    ctx.StatusCode(iris.StatusNotFound)         // 404 Not Found
    ctx.StatusCode(iris.StatusMethodNotAllowed) // 405 Method Not Allowed
    ctx.StatusCode(iris.StatusConflict)          // 409 Conflict
    ctx.StatusCode(iris.StatusUnprocessableEntity) // 422 Unprocessable Entity
    ctx.StatusCode(iris.StatusTooManyRequests)  // 429 Too Many Requests
    
    // 5xx 服务器错误状态码
    ctx.StatusCode(iris.StatusInternalServerError) // 500 Internal Server Error
    ctx.StatusCode(iris.StatusNotImplemented)    // 501 Not Implemented
    ctx.StatusCode(iris.StatusBadGateway)        // 502 Bad Gateway
    ctx.StatusCode(iris.StatusServiceUnavailable) // 503 Service Unavailable
    ctx.StatusCode(iris.StatusGatewayTimeout)     // 504 Gateway Timeout
}

func conditionalStatusCodes(ctx iris.Context) {
    // 根据条件返回不同状态码
    exists, err := checkResourceExists(ctx.Params().GetString("id"))
    if err != nil {
        ctx.StatusCode(iris.StatusInternalServerError)
        ctx.JSON(iris.Map{"error": "服务器内部错误"})
        return
    }
    
    if !exists {
        ctx.StatusCode(iris.StatusNotFound)
        ctx.JSON(iris.Map{"error": "资源不存在"})
        return
    }
    
    // 继续处理...
    ctx.StatusCode(iris.StatusOK)
    ctx.JSON(iris.Map{"message": "资源存在"})
}
```

### 2. 自定义状态码处理

```go
// 错误处理中间件
func ErrorHandlerMiddleware(ctx iris.Context) {
    ctx.Next()
    
    // 根据错误类型设置状态码
    if err := ctx.Values().Get("error"); err != nil {
        switch e := err.(type) {
        case ValidationError:
            ctx.StatusCode(iris.StatusBadRequest)
        case AuthenticationError:
            ctx.StatusCode(iris.StatusUnauthorized)
        case AuthorizationError:
            ctx.StatusCode(iris.StatusForbidden)
        case NotFoundError:
            ctx.StatusCode(iris.StatusNotFound)
        case ConflictError:
            ctx.StatusCode(iris.StatusConflict)
        default:
            ctx.StatusCode(iris.StatusInternalServerError)
        }
        
        ctx.JSON(iris.Map{
            "error": e.Error(),
            "code":   ctx.GetStatusCode(),
        })
    }
}

// 自定义错误类型
type ValidationError struct {
    Field string
    Message string
}

func (e ValidationError) Error() string {
    return fmt.Sprintf("验证错误: %s - %s", e.Field, e.Message)
}

type AuthenticationError struct {
    Message string
}

func (e AuthenticationError) Error() string {
    return e.Message
}

type AuthorizationError struct {
    Message string
}

func (e AuthorizationError) Error() string {
    return e.Message
}

type NotFoundError struct {
    Resource string
}

func (e NotFoundError) Error() string {
    return fmt.Sprintf("%s 不存在", e.Resource)
}

type ConflictError struct {
    Message string
}

func (e ConflictError) Error() string {
    return e.Message
}
```

## 响应头控制

### 1. 设置响应头

```go
func responseHeaders(ctx iris.Context) {
    // 设置基本响应头
    ctx.Header("Content-Type", "application/json")
    ctx.Header("X-Custom-Header", "custom-value")
    
    // 设置缓存控制
    ctx.Header("Cache-Control", "no-cache, no-store, must-revalidate")
    ctx.Header("Pragma", "no-cache")
    ctx.Header("Expires", "0")
    
    // 设置安全头
    ctx.Header("X-Content-Type-Options", "nosniff")
    ctx.Header("X-Frame-Options", "DENY")
    ctx.Header("X-XSS-Protection", "1; mode=block")
    ctx.Header("Strict-Transport-Security", "max-age=31536000; includeSubDomains")
    
    // 设置跨域头
    ctx.Header("Access-Control-Allow-Origin", "*")
    ctx.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
    ctx.Header("Access-Control-Allow-Headers", "Content-Type, Authorization")
    
    // 设置内容长度
    content := "Hello, World!"
    ctx.Header("Content-Length", fmt.Sprintf("%d", len(content)))
    ctx.WriteString(content)
}

func conditionalHeaders(ctx iris.Context) {
    // 根据 Content-Type 设置响应头
    accept := ctx.GetHeader("Accept")
    
    if strings.Contains(accept, "application/json") {
        ctx.ContentType("application/json")
        ctx.JSON(iris.Map{"message": "JSON response"})
    } else if strings.Contains(accept, "text/html") {
        ctx.ContentType("text/html")
        ctx.HTML("<h1>HTML response</h1>")
    } else {
        ctx.ContentType("text/plain")
        ctx.WriteString("Plain text response")
    }
    
    // 根据用户代理设置特殊头
    userAgent := ctx.GetHeader("User-Agent")
    if strings.Contains(userAgent, "curl") {
        ctx.Header("X-API-Version", "1.0")
    }
}
```

### 2. 内容协商

```go
func contentNegotiation(ctx iris.Context) {
    data := iris.Map{
        "message": "Hello, World!",
        "timestamp": time.Now().Unix(),
    }
    
    accept := ctx.GetHeader("Accept")
    
    switch {
    case strings.Contains(accept, "application/json"):
        ctx.ContentType("application/json")
        ctx.JSON(data)
        
    case strings.Contains(accept, "application/xml"):
        ctx.ContentType("application/xml")
        ctx.XML(data)
        
    case strings.Contains(accept, "text/html"):
        ctx.ContentType("text/html")
        ctx.HTML(fmt.Sprintf("<h1>%s</h1><p>Timestamp: %d</p>", 
            data["message"], data["timestamp"]))
            
    case strings.Contains(accept, "text/plain"):
        ctx.ContentType("text/plain")
        ctx.WriteString(fmt.Sprintf("Message: %s, Timestamp: %d", 
            data["message"], data["timestamp"]))
            
    default:
        // 默认返回 JSON
        ctx.ContentType("application/json")
        ctx.JSON(data)
    }
}
```

## 流式响应

### 1. 大数据流响应

```go
func streamResponse(ctx iris.Context) {
    // 设置流式响应头
    ctx.ContentType("application/json")
    ctx.Header("Transfer-Encoding", "chunked")
    
    // 创建流式写入器
    flusher, ok := ctx.ResponseWriter().(http.Flusher)
    if !ok {
        ctx.StatusCode(iris.StatusInternalServerError)
        ctx.JSON(iris.Map{"error": "流式响应不支持"})
        return
    }
    
    // 发送数据流
    for i := 0; i < 10; i++ {
        data := iris.Map{
            "index": i,
            "message": fmt.Sprintf("数据块 %d", i),
            "timestamp": time.Now().Unix(),
        }
        
        jsonData, _ := json.Marshal(data)
        ctx.Write(jsonData)
        ctx.Write([]byte("\n"))
        
        // 刷新缓冲区
        flusher.Flush()
        
        // 模拟延迟
        time.Sleep(500 * time.Millisecond)
    }
}
```

### 2. 服务器发送事件 (SSE)

```go
func serverSentEvents(ctx iris.Context) {
    // 设置 SSE 响应头
    ctx.ContentType("text/event-stream")
    ctx.Header("Cache-Control", "no-cache")
    ctx.Header("Connection", "keep-alive")
    
    // 创建 SSE 写入器
    flusher, ok := ctx.ResponseWriter().(http.Flusher)
    if !ok {
        ctx.StatusCode(iris.StatusInternalServerError)
        return
    }
    
    // 发送事件流
    ticker := time.NewTicker(2 * time.Second)
    defer ticker.Stop()
    
    counter := 0
    for {
        select {
        case <-ticker.C:
            counter++
            
            // 构建事件数据
            event := fmt.Sprintf("data: %s\n\n", 
                fmt.Sprintf(`{"message": "实时更新 %d", "timestamp": %d}`, 
                    counter, time.Now().Unix()))
            
            // 发送事件
            ctx.Write([]byte(event))
            flusher.Flush()
            
            // 发送10次后结束
            if counter >= 10 {
                return
            }
            
        case <-ctx.Request().Context().Done():
            // 客户端断开连接
            return
        }
    }
}
```

## 文件响应

### 1. 文件下载

```go
func fileDownload(ctx iris.Context) {
    filename := ctx.Params().Get("filename")
    filepath := filepath.Join("downloads", filename)
    
    // 检查文件是否存在
    if _, err := os.Stat(filepath); os.IsNotExist(err) {
        ctx.StatusCode(iris.StatusNotFound)
        ctx.JSON(iris.Map{"error": "文件不存在"})
        return
    }
    
    // 设置下载头
    ctx.SendFile(filepath)
    
    // 或者自定义下载头
    ctx.Header("Content-Description", "File Transfer")
    ctx.Header("Content-Type", "application/octet-stream")
    ctx.Header("Content-Disposition", fmt.Sprintf("attachment; filename=%s", filename))
    ctx.Header("Content-Transfer-Encoding", "binary")
    ctx.Header("Expires", "0")
    ctx.Header("Cache-Control", "must-revalidate")
    ctx.Header("Pragma", "public")
    
    ctx.SendFile(filepath)
}

func rangeFileDownload(ctx iris.Context) {
    filename := ctx.Params().Get("filename")
    filepath := filepath.Join("downloads", filename)
    
    // 支持范围请求（断点续传）
    ctx.Header("Accept-Ranges", "bytes")
    
    file, err := os.Open(filepath)
    if err != nil {
        ctx.StatusCode(iris.StatusNotFound)
        return
    }
    defer file.Close()
    
    fileInfo, _ := file.Stat()
    fileSize := fileInfo.Size()
    
    // 处理范围请求
    rangeHeader := ctx.GetHeader("Range")
    if rangeHeader != "" {
        // 解析范围头
        ranges := strings.Split(strings.TrimPrefix(rangeHeader, "bytes="), "-")
        start, _ := strconv.ParseInt(ranges[0], 10, 64)
        end := fileSize - 1
        
        if len(ranges) > 1 && ranges[1] != "" {
            end, _ = strconv.ParseInt(ranges[1], 10, 64)
        }
        
        // 设置部分内容响应头
        ctx.StatusCode(iris.StatusPartialContent)
        ctx.Header("Content-Range", fmt.Sprintf("bytes %d-%d/%d", start, end, fileSize))
        ctx.Header("Content-Length", fmt.Sprintf("%d", end-start+1))
        
        // 发送文件内容
        file.Seek(start, 0)
        io.CopyN(ctx.ResponseWriter(), file, end-start+1)
    } else {
        // 发送完整文件
        ctx.Header("Content-Length", fmt.Sprintf("%d", fileSize))
        io.Copy(ctx.ResponseWriter(), file)
    }
}
```

### 2. 图片响应

```go
func imageResponse(ctx iris.Context) {
    imageID := ctx.Params().Get("id")
    
    // 获取图片信息
    imageInfo, err := getImageInfo(imageID)
    if err != nil {
        ctx.StatusCode(iris.StatusNotFound)
        ctx.JSON(iris.Map{"error": "图片不存在"})
        return
    }
    
    // 根据请求参数处理图片
    width, _ := ctx.URLParamInt("width")
    height, _ := ctx.URLParamInt("height")
    quality, _ := ctx.URLParamInt("quality")
    
    if quality == 0 {
        quality = 80
    }
    
    // 处理图片
    processedImage, err := processImage(imageInfo.Path, width, height, quality)
    if err != nil {
        ctx.StatusCode(iris.StatusInternalServerError)
        ctx.JSON(iris.Map{"error": "图片处理失败"})
        return
    }
    
    // 设置图片响应头
    ctx.ContentType(imageInfo.ContentType)
    ctx.Header("Cache-Control", "public, max-age=31536000") // 1年缓存
    ctx.Header("ETag", fmt.Sprintf(`"%s"`, imageInfo.ETag))
    
    // 检查 ETag
    ifMatch := ctx.GetHeader("If-None-Match")
    if ifMatch == fmt.Sprintf(`"%s"`, imageInfo.ETag) {
        ctx.StatusCode(iris.StatusNotModified)
        return
    }
    
    // 发送图片数据
    ctx.Write(processedImage)
}
```

## 响应压缩

### 1. Gzip 压缩

```go
func gzipResponse(ctx iris.Context) {
    // 检查客户端是否支持压缩
    acceptEncoding := ctx.GetHeader("Accept-Encoding")
    if !strings.Contains(acceptEncoding, "gzip") {
        // 客户端不支持压缩，发送原始数据
        ctx.JSON(iris.Map{"message": "未压缩的响应"})
        return
    }
    
    // 启用压缩
    ctx.Gzip(true)
    
    // 发送大量数据
    data := make([]iris.Map, 1000)
    for i := 0; i < 1000; i++ {
        data[i] = iris.Map{
            "id":       i,
            "name":     fmt.Sprintf("Item %d", i),
            "value":    fmt.Sprintf("Value %d", i),
            "created":  time.Now().Add(-time.Duration(i) * time.Hour).Format(time.RFC3339),
        }
    }
    
    ctx.JSON(iris.Map{
        "message": "压缩的响应",
        "data":    data,
    })
}
```

### 2. 自定义压缩

```go
func customCompression(ctx iris.Context) {
    // 检查客户端支持的压缩算法
    acceptEncoding := ctx.GetHeader("Accept-Encoding")
    
    var responseData []byte
    var contentEncoding string
    var contentType string
    
    // 准备响应数据
    data := iris.Map{
        "message": "自定义压缩响应",
        "timestamp": time.Now().Unix(),
        "data": generateLargeData(),
    }
    
    jsonData, _ := json.Marshal(data)
    
    // 选择压缩算法
    switch {
    case strings.Contains(acceptEncoding, "gzip"):
        responseData, _ = compressGzip(jsonData)
        contentEncoding = "gzip"
        contentType = "application/json"
        
    case strings.Contains(acceptEncoding, "deflate"):
        responseData, _ = compressDeflate(jsonData)
        contentEncoding = "deflate"
        contentType = "application/json"
        
    case strings.Contains(acceptEncoding, "br"):
        responseData, _ = compressBrotli(jsonData)
        contentEncoding = "br"
        contentType = "application/json"
        
    default:
        responseData = jsonData
        contentEncoding = "identity"
        contentType = "application/json"
    }
    
    // 设置响应头
    ctx.ContentType(contentType)
    ctx.Header("Content-Encoding", contentEncoding)
    ctx.Header("Content-Length", fmt.Sprintf("%d", len(responseData)))
    ctx.Header("Vary", "Accept-Encoding")
    
    // 发送压缩数据
    ctx.Write(responseData)
}
```

## 最佳实践

### 1. 响应格式一致性

```go
// 统一的响应格式
type APIResponse struct {
    Success   bool        `json:"success"`
    Message   string      `json:"message"`
    Data      interface{} `json:"data,omitempty"`
    Errors    interface{} `json:"errors,omitempty"`
    Timestamp int64       `json:"timestamp"`
    RequestID string      `json:"request_id,omitempty"`
}

// 成功响应
func APISuccess(ctx iris.Context, message string, data interface{}) {
    response := APIResponse{
        Success:   true,
        Message:   message,
        Data:      data,
        Timestamp: time.Now().Unix(),
        RequestID: ctx.Values().GetStringDefault("request_id", ""),
    }
    ctx.JSON(response)
}

// 错误响应
func APIError(ctx iris.Context, code int, message string, errors interface{}) {
    response := APIResponse{
        Success:   false,
        Message:   message,
        Errors:    errors,
        Timestamp: time.Now().Unix(),
        RequestID: ctx.Values().GetStringDefault("request_id", ""),
    }
    ctx.StatusCode(code)
    ctx.JSON(response)
}
```

### 2. 性能优化

```go
func optimizedResponse(ctx iris.Context) {
    // 使用连接池
    buffer := responseBufferPool.Get().(*bytes.Buffer)
    defer func() {
        buffer.Reset()
        responseBufferPool.Put(buffer)
    }()
    
    // 准备响应数据
    data := prepareResponseData()
    
    // 编码到缓冲区
    encoder := json.NewEncoder(buffer)
    encoder.SetEscapeHTML(false)
    if err := encoder.Encode(data); err != nil {
        ctx.StatusCode(iris.StatusInternalServerError)
        return
    }
    
    // 设置响应头
    ctx.ContentType("application/json")
    ctx.Header("Content-Length", fmt.Sprintf("%d", buffer.Len()))
    
    // 写入响应
    ctx.Write(buffer.Bytes())
}
```

## 下一步

现在您已经掌握了响应处理的各种技巧，建议继续学习：

1. [静态文件](./06-静态文件.md) - 学习静态文件服务
2. [模板引擎](./07-模板引擎.md) - 掌握模板渲染
3. [数据库集成](./08-数据库集成.md) - 学习数据库操作

## 相关资源

- [Iris 响应处理文档](https://iris-go.com/context#response-writers)
- [HTTP 响应状态码](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)
- [Content Negotiation](https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation)