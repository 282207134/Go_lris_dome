# 03 - 中间件使用

## 中间件概述

中间件是处理 HTTP 请求的函数，它在请求到达最终处理器之前执行。Iris 的中间件系统非常灵活，支持全局中间件、路由组中间件和单个路由中间件。

## 中间件基础

### 1. 中间件函数签名

```go
// 中间件函数的基本签名
func middlewareName(ctx iris.Context) {
    // 前置处理逻辑
    
    // 调用下一个处理器
    ctx.Next()
    
    // 后置处理逻辑
}

// 示例：简单的日志中间件
func LoggerMiddleware(ctx iris.Context) {
    start := time.Now()
    
    // 记录请求开始
    fmt.Printf("开始处理: %s %s\n", ctx.Method(), ctx.Path())
    
    // 调用下一个处理器
    ctx.Next()
    
    // 记录请求结束
    duration := time.Since(start)
    fmt.Printf("完成处理: %s %s - 耗时: %v\n", 
        ctx.Method(), ctx.Path(), duration)
}
```

### 2. 注册中间件

```go
// 全局中间件 - 所有路由都会使用
app.Use(LoggerMiddleware)
app.Use(recover.New())

// 全局后置中间件 - 在所有处理器执行后执行
app.Done(finalizeMiddleware)

// 路由级中间件 - 只对特定路由生效
app.Get("/protected", authMiddleware, protectedHandler)

// 路由组中间件 - 对整个路由组生效
api := app.Party("/api")
api.Use(corsMiddleware)
api.Use(rateLimitMiddleware)
{
    api.Get("/users", getUsersHandler)
    api.Post("/users", createUserHandler)
}
```

## 内置中间件

### 1. 恢复中间件

```go
import "github.com/kataras/iris/v12/middleware/recover"

// 使用内置的恢复中间件
app.Use(recover.New())

// 自定义恢复中间件
app.Use(recover.New(recover.Options{
    Logger:         logger,
    StackTrace:     true,
    Notify:         func(err interface{}) {
        // 发送错误通知
    },
}))
```

### 2. 日志中间件

```go
import "github.com/kataras/iris/v12/middleware/logger"

// 使用内置的日志中间件
app.Use(logger.New())

// 自定义日志配置
app.Use(logger.New(logger.Config{
    // 显示请求状态
    Status: true,
    // 显示 IP 地址
    IP: true,
    // 显示请求方法
    Method: true,
    // 显示请求路径
    Path: true,
    // 显示查询参数
    Query: true,
    // 显示请求头
    Headers: false,
    // 显示响应时间
    Latency: true,
    // 自定义日志格式
    LogFunc: func(endTime time.Time, latency time.Duration, status, ip, method, path string, message interface{}) {
        log.Printf("[%s] %s %s %s %v %v", 
            endTime.Format("2006-01-02 15:04:05"),
            method, path, status, latency, message)
    },
}))
```

### 3. CORS 中间件

```go
// 自定义 CORS 中间件
func CORSMiddleware(ctx iris.Context) {
    ctx.Header("Access-Control-Allow-Origin", "*")
    ctx.Header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
    ctx.Header("Access-Control-Allow-Headers", "Origin, Content-Type, Accept, Authorization")
    ctx.Header("Access-Control-Allow-Credentials", "true")

    // 处理预检请求
    if ctx.Method() == "OPTIONS" {
        ctx.StatusCode(iris.StatusNoContent)
        return
    }

    ctx.Next()
}

// 使用 CORS 中间件
app.Use(CORSMiddleware)
```

## 自定义中间件

### 1. 认证中间件

```go
// JWT 认证中间件
func JWTAuthentication(ctx iris.Context) {
    // 从请求头获取令牌
    authHeader := ctx.GetHeader("Authorization")
    if authHeader == "" {
        ctx.StatusCode(iris.StatusUnauthorized)
        ctx.JSON(iris.Map{"error": "缺少认证令牌"})
        return
    }

    // 验证 Bearer 前缀
    const bearerPrefix = "Bearer "
    if !strings.HasPrefix(authHeader, bearerPrefix) {
        ctx.StatusCode(iris.StatusUnauthorized)
        ctx.JSON(iris.Map{"error": "令牌格式错误"})
        return
    }

    // 提取令牌
    token := authHeader[len(bearerPrefix):]
    
    // 验证令牌
    claims, err := validateJWT(token)
    if err != nil {
        ctx.StatusCode(iris.StatusUnauthorized)
        ctx.JSON(iris.Map{"error": "无效的令牌"})
        return
    }

    // 将用户信息存储到上下文
    ctx.Values().Set("user_id", claims.UserID)
    ctx.Values().Set("username", claims.Username)
    ctx.Values().Set("role", claims.Role)

    ctx.Next()
}
```

### 2. 角色验证中间件

```go
// 角色验证中间件工厂函数
func RequireRole(roles ...string) iris.Handler {
    return func(ctx iris.Context) {
        // 获取用户角色
        userRole, ok := ctx.Values().GetString("role")
        if !ok {
            ctx.StatusCode(iris.StatusForbidden)
            ctx.JSON(iris.Map{"error": "无法获取用户角色"})
            return
        }

        // 检查用户权限
        hasPermission := false
        for _, role := range roles {
            if userRole == role {
                hasPermission = true
                break
            }
        }

        if !hasPermission {
            ctx.StatusCode(iris.StatusForbidden)
            ctx.JSON(iris.Map{"error": "权限不足"})
            return
        }

        ctx.Next()
    }
}

// 使用示例
app.Get("/admin", authMiddleware, RequireRole("admin"), adminHandler)
app.Get("/users", authMiddleware, RequireRole("admin", "manager"), usersHandler)
```

### 3. 限流中间件

```go
// 限流中间件
func RateLimitMiddleware(requests int, duration time.Duration) iris.Handler {
    limiter := make(map[string]*rate.Limiter)
    var mutex sync.Mutex

    return func(ctx iris.Context) {
        clientIP := getClientIP(ctx)
        
        mutex.Lock()
        if limiter[clientIP] == nil {
            limiter[clientIP] = rate.NewLimiter(rate.Every(duration), requests)
        }
        limiter := limiter[clientIP]
        mutex.Unlock()

        if !limiter.Allow() {
            ctx.StatusCode(iris.StatusTooManyRequests)
            ctx.JSON(iris.Map{
                "error": "请求过于频繁，请稍后再试",
                "retry_after": duration.String(),
            })
            return
        }

        ctx.Next()
    }
}

// 使用限流中间件
app.Use(RateLimitMiddleware(100, time.Minute)) // 每分钟100次请求
```

### 4. 请求ID 中间件

```go
// 请求ID中间件
func RequestIDMiddleware(ctx iris.Context) {
    // 从请求头获取请求ID，如果没有则生成新的
    requestID := ctx.GetHeader("X-Request-ID")
    if requestID == "" {
        requestID = generateRequestID()
    }

    // 设置请求ID到响应头和上下文
    ctx.Header("X-Request-ID", requestID)
    ctx.Values().Set("request_id", requestID)

    ctx.Next()
}

// 生成请求ID
func generateRequestID() string {
    return fmt.Sprintf("%d-%s", 
        time.Now().UnixNano(), 
        randomString(8))
}
```

### 5. 压缩中间件

```go
// Gzip 压缩中间件
func GzipMiddleware(ctx iris.Context) {
    // 检查客户端是否支持压缩
    acceptEncoding := ctx.GetHeader("Accept-Encoding")
    if !strings.Contains(acceptEncoding, "gzip") {
        ctx.Next()
        return
    }

    // 创建压缩写入器
    writer := ctx.GzipResponseWriter()
    defer writer.Close()

    // 设置响应头
    ctx.Header("Content-Encoding", "gzip")
    ctx.Header("Vary", "Accept-Encoding")

    ctx.Next()
}

// 使用压缩中间件
app.Use(GzipMiddleware)
```

## 中间件链

### 1. 中间件执行顺序

```go
// 中间件执行顺序示例
func Middleware1(ctx iris.Context) {
    fmt.Println("Middleware 1 - Before")
    ctx.Next()
    fmt.Println("Middleware 1 - After")
}

func Middleware2(ctx iris.Context) {
    fmt.Println("Middleware 2 - Before")
    ctx.Next()
    fmt.Println("Middleware 2 - After")
}

func Handler(ctx iris.Context) {
    fmt.Println("Handler")
}

// 注册顺序
app.Use(Middleware1)
app.Use(Middleware2)
app.Get("/", Handler)

// 输出顺序：
// Middleware 1 - Before
// Middleware 2 - Before
// Handler
// Middleware 2 - After
// Middleware 1 - After
```

### 2. 条件中间件

```go
// 条件中间件
func ConditionalMiddleware(condition func(ctx iris.Context) bool, middleware iris.Handler) iris.Handler {
    return func(ctx iris.Context) {
        if condition(ctx) {
            middleware(ctx)
        } else {
            ctx.Next()
        }
    }
}

// 使用示例：只对 API 路由应用认证
app.Use(ConditionalMiddleware(
    func(ctx iris.Context) bool {
        return strings.HasPrefix(ctx.Path(), "/api/")
    },
    authMiddleware,
))
```

## 中间件工厂

### 1. 配置化中间件

```go
// 配置化日志中间件
type LogConfig struct {
    SkipPaths []string
    MaxBody   int64
    Level     string
}

func LogMiddleware(config LogConfig) iris.Handler {
    return func(ctx iris.Context) {
        // 跳过指定路径
        for _, path := range config.SkipPaths {
            if ctx.Path() == path {
                ctx.Next()
                return
            }
        }

        // 记录请求日志
        logRequest(ctx, config)
        ctx.Next()
    }
}

// 使用配置化中间件
app.Use(LogMiddleware(LogConfig{
    SkipPaths: []string{"/health", "/metrics"},
    MaxBody:   1024,
    Level:     "info",
}))
```

### 2. 中间件组合

```go
// 中间件组合
func SecurityMiddleware() iris.Handler {
    return func(ctx iris.Context) {
        // 安全头设置
        ctx.Header("X-Content-Type-Options", "nosniff")
        ctx.Header("X-Frame-Options", "DENY")
        ctx.Header("X-XSS-Protection", "1; mode=block")
        ctx.Header("Strict-Transport-Security", "max-age=31536000; includeSubDomains")
        
        ctx.Next()
    }
}

// 组合多个中间件
func API middleware() iris.Handler {
    return func(ctx iris.Context) {
        SecurityMiddleware()(ctx)
        CORSMiddleware()(ctx)
        RequestIDMiddleware()(ctx)
        RateLimitMiddleware(60, time.Minute)(ctx)
    }
}

// 使用组合中间件
api := app.Party("/api")
api.Use(API middleware())
```

## 中间件测试

### 1. 单元测试

```go
func TestAuthMiddleware(t *testing.T) {
    app := iris.New()
    app.Use(authMiddleware)
    
    app.Get("/protected", func(ctx iris.Context) {
        ctx.JSON(iris.Map{"message": "success"})
    })

    // 测试无令牌访问
    e := httptest.New(t, app)
    e.GET("/protected").Expect().Status(iris.StatusUnauthorized)

    // 测试有效令牌
    e.GET("/protected").
        WithHeader("Authorization", "Bearer valid-token").
        Expect().Status(iris.StatusOK)
}
```

## 最佳实践

### 1. 中间件设计原则

- **单一职责**: 每个中间件只做一件事
- **可组合性**: 中间件应该可以自由组合
- **无状态**: 尽量设计无状态的中间件
- **错误处理**: 统一的错误处理机制

### 2. 性能优化

```go
// 缓存中间件
func CacheMiddleware(duration time.Duration) iris.Handler {
    cache := make(map[string]cacheEntry)
    var mutex sync.RWMutex

    return func(ctx iris.Context) {
        if ctx.Method() != "GET" {
            ctx.Next()
            return
        }

        key := ctx.Request().URL.String()
        
        // 检查缓存
        mutex.RLock()
        if entry, exists := cache[key]; exists && time.Since(entry.timestamp) < duration {
            mutex.RUnlock()
            ctx.ContentType(entry.contentType)
            ctx.Write(entry.data)
            return
        }
        mutex.RUnlock()

        // 捕获响应
        writer := &responseWriter{ResponseWriter: ctx.ResponseWriter()}
        ctx.ResponseWriter().SetWriter(writer)
        ctx.Next()

        // 存储到缓存
        mutex.Lock()
        cache[key] = cacheEntry{
            data:        writer.data,
            contentType: writer.contentType,
            timestamp:   time.Now(),
        }
        mutex.Unlock()
    }
}
```

### 3. 错误处理

```go
// 错误处理中间件
func ErrorHandlerMiddleware(ctx iris.Context) {
    defer func() {
        if err := recover(); err != nil {
            // 记录错误
            log.Printf("Panic recovered: %v\n%s", err, debug.Stack())
            
            // 返回友好错误信息
            ctx.StatusCode(iris.StatusInternalServerError)
            ctx.JSON(iris.Map{
                "error": "服务器内部错误",
                "code":  "INTERNAL_SERVER_ERROR",
            })
        }
    }()
    
    ctx.Next()
}
```

## 下一步

现在您已经掌握了 Iris 的中间件系统，建议继续学习：

1. [请求处理](./04-请求处理.md) - 深入了解请求处理机制
2. [响应处理](./05-响应处理.md) - 掌握各种响应格式
3. [静态文件](./06-静态文件.md) - 学习静态文件服务

## 相关资源

- [Iris 中间件文档](https://iris-go.com/middleware)
- [Go 中间件模式](https://medium.com/@matryer/writing-middleware-in-golang-and-how-middleware-makes-chains-happy-537c5f26c821)
- [HTTP 中间件概念](https://expressjs.com/en/guide/using-middleware.html)