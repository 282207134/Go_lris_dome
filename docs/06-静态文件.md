# 06 - 静态文件服务

## 静态文件服务概述

Iris 提供了强大的静态文件服务功能，支持单文件服务、目录服务、缓存控制、压缩、范围请求等高级特性。可以用于服务 CSS、JavaScript、图片、文档等静态资源。

## 基本静态文件服务

### 1. 单个文件服务

```go
func setupStaticFiles(app *iris.Application) {
    // 服务单个文件
    app.Get("/favicon.ico", func(ctx iris.Context) {
        ctx.SendFile("static/favicon.ico")
    })
    
    // 服务 robots.txt
    app.Get("/robots.txt", func(ctx iris.Context) {
        ctx.SendFile("static/robots.txt")
    })
    
    // 服务 sitemap.xml
    app.Get("/sitemap.xml", func(ctx iris.Context) {
        ctx.SendFile("static/sitemap.xml")
    })
}
```

### 2. 目录服务

```go
func setupStaticDirectories(app *iris.Application) {
    // 基本目录服务
    app.HandleDir("/static", iris.Dir("./static"))
    
    // 服务多个目录
    app.HandleDir("/assets", iris.Dir("./assets"))
    app.HandleDir("/uploads", iris.Dir("./uploads"))
    app.HandleDir("/downloads", iris.Dir("./downloads"))
    
    // 带配置的目录服务
    app.HandleDir("/public", iris.Dir("./public"), iris.DirOptions{
        IndexName: "index.html",        // 默认首页文件
        Gzip:      true,                // 启用 gzip 压缩
        ShowList:  false,               // 不显示目录列表
        Cache: iris.DirCacheOptions{
            Compress:  true,            // 启用压缩
            Encodings: []string{"gzip", "deflate"},
        },
    })
}
```

### 3. 路径映射

```go
func pathMapping(app *iris.Application) {
    // 将不同的路径映射到同一目录
    app.HandleDir("/css", iris.Dir("./static/css"))
    app.HandleDir("/js", iris.Dir("./static/js"))
    app.HandleDir("/images", iris.Dir("./static/images"))
    app.HandleDir("/fonts", iris.Dir("./static/fonts"))
    
    // 多级路径映射
    app.HandleDir("/assets/css", iris.Dir("./static/css"))
    app.HandleDir("/assets/js", iris.Dir("./static/js"))
    app.HandleDir("/assets/images", iris.Dir("./static/images"))
}
```

## 高级配置

### 1. 目录选项配置

```go
func advancedDirectoryConfig(app *iris.Application) {
    // 完整的目录配置
    app.HandleDir("/files", iris.Dir("./files"), iris.DirOptions{
        // 默认文件
        IndexName: "index.html",
        
        // 启用 gzip 压缩
        Gzip: true,
        
        // 显示目录列表
        ShowList: true,
        
        // 缓存配置
        Cache: iris.DirCacheOptions{
            Compress: true,
            Encodings: []string{"gzip", "deflate", "br"},
        },
        
        // 自定义处理函数
        AssetValidator: func(filename string) bool {
            // 只允许特定扩展名的文件
            allowedExts := []string{".html", ".css", ".js", ".png", ".jpg", ".gif", ".svg"}
            for _, ext := range allowedExts {
                if strings.HasSuffix(strings.ToLower(filename), ext) {
                    return true
                }
            }
            return false
        },
        
        // 自定义文件名处理
        AssetName: func(filename string) string {
            // 可以修改文件名（如添加版本号）
            return filename
        },
    })
}
```

### 2. 缓存控制

```go
func cacheControl(app *iris.Application) {
    // 为不同类型的静态资源设置不同的缓存策略
    app.HandleDir("/static", iris.Dir("./static"), iris.DirOptions{
        Cache: iris.DirCacheOptions{
            Compress: true,
            Encodings: []string{"gzip", "deflate"},
        },
    })
    
    // 自定义缓存中间件
    cacheMiddleware := func(ctx iris.Context) {
        path := ctx.Path()
        
        // 根据文件类型设置缓存头
        switch {
        case strings.HasSuffix(path, ".css"), strings.HasSuffix(path, ".js"):
            // CSS 和 JS 文件缓存 1 年
            ctx.Header("Cache-Control", "public, max-age=31536000, immutable")
            
        case strings.HasSuffix(path, ".png"), strings.HasSuffix(path, ".jpg"), 
             strings.HasSuffix(path, ".gif"), strings.HasSuffix(path, ".svg"):
            // 图片文件缓存 1 年
            ctx.Header("Cache-Control", "public, max-age=31536000")
            
        case strings.HasSuffix(path, ".html"):
            // HTML 文件不缓存
            ctx.Header("Cache-Control", "no-cache, no-store, must-revalidate")
            
        default:
            // 其他文件缓存 1 小时
            ctx.Header("Cache-Control", "public, max-age=3600")
        }
        
        // 设置 ETag
        ctx.Header("ETag", generateETag(path))
        
        ctx.Next()
    }
    
    // 应用缓存中间件
    app.UseRouter(cacheMiddleware)
}

func generateETag(path string) string {
    // 基于文件路径和修改时间生成 ETag
    fileInfo, err := os.Stat("./static" + path)
    if err != nil {
        return fmt.Sprintf(`"%s"`, "default")
    }
    
    return fmt.Sprintf(`"%x"`, fileInfo.ModTime().UnixNano())
}
```

### 3. 安全配置

```go
func securityConfig(app *iris.Application) {
    // 安全中间件
    securityMiddleware := func(ctx iris.Context) {
        path := ctx.Path()
        
        // 防止访问敏感文件
        forbiddenFiles := []string{
            ".env", ".git", ".svn", ".htaccess", "web.config",
            "config.php", "database.yml", "secrets.json",
        }
        
        for _, forbidden := range forbiddenFiles {
            if strings.Contains(path, forbidden) {
                ctx.StatusCode(iris.StatusForbidden)
                ctx.JSON(iris.Map{"error": "访问被禁止"})
                return
            }
        }
        
        // 防止目录遍历攻击
        if strings.Contains(path, "..") {
            ctx.StatusCode(iris.StatusBadRequest)
            ctx.JSON(iris.Map{"error": "无效的路径"})
            return
        }
        
        // 设置安全头
        ctx.Header("X-Content-Type-Options", "nosniff")
        ctx.Header("X-Frame-Options", "DENY")
        ctx.Header("X-XSS-Protection", "1; mode=block")
        
        ctx.Next()
    }
    
    app.UseRouter(securityMiddleware)
    
    // 配置安全的静态文件服务
    app.HandleDir("/static", iris.Dir("./static"), iris.DirOptions{
        ShowList: false,  // 不显示目录列表
        AssetValidator: func(filename string) bool {
            // 只允许安全的文件类型
            ext := strings.ToLower(filepath.Ext(filename))
            allowedExts := map[string]bool{
                ".html": true, ".css": true, ".js": true,
                ".png": true, ".jpg": true, ".jpeg": true, ".gif": true, ".svg": true,
                ".ico": true, ".woff": true, ".woff2": true, ".ttf": true, ".eot": true,
                ".pdf": true, ".txt": true, ".xml": true, ".json": true,
            }
            return allowedExts[ext]
        },
    })
}
```

## 文件上传处理

### 1. 基本文件上传

```go
func fileUploadHandler(ctx iris.Context) {
    // 获取上传的文件
    file, info, err := ctx.FormFile("file")
    if err != nil {
        ctx.StatusCode(iris.StatusBadRequest)
        ctx.JSON(iris.Map{
            "error": "文件上传失败",
            "details": err.Error(),
        })
        return
    }
    defer file.Close()
    
    // 验证文件大小
    maxSize := int64(10 << 20) // 10MB
    if info.Size > maxSize {
        ctx.StatusCode(iris.StatusBadRequest)
        ctx.JSON(iris.Map{
            "error": "文件大小超过限制",
            "max_size": maxSize,
            "file_size": info.Size,
        })
        return
    }
    
    // 验证文件类型
    allowedTypes := []string{
        "image/jpeg", "image/png", "image/gif", "image/svg+xml",
        "application/pdf", "text/plain", "application/json",
    }
    
    contentType := info.Header.Get("Content-Type")
    if !contains(allowedTypes, contentType) {
        ctx.StatusCode(iris.StatusBadRequest)
        ctx.JSON(iris.Map{
            "error": "不支持的文件类型",
            "content_type": contentType,
            "allowed_types": allowedTypes,
        })
        return
    }
    
    // 生成唯一文件名
    filename := generateUniqueFilename(info.Filename)
    savePath := filepath.Join("uploads", filename)
    
    // 确保目录存在
    if err := os.MkdirAll("uploads", 0755); err != nil {
        ctx.StatusCode(iris.StatusInternalServerError)
        ctx.JSON(iris.Map{"error": "创建上传目录失败"})
        return
    }
    
    // 保存文件
    if err := saveUploadedFile(file, savePath); err != nil {
        ctx.StatusCode(iris.StatusInternalServerError)
        ctx.JSON(iris.Map{
            "error": "文件保存失败",
            "details": err.Error(),
        })
        return
    }
    
    // 返回上传结果
    ctx.JSON(iris.Map{
        "message": "文件上传成功",
        "filename": filename,
        "original_name": info.Filename,
        "size": info.Size,
        "content_type": contentType,
        "url": "/uploads/" + filename,
    })
}
```

### 2. 多文件上传

```go
func multiFileUploadHandler(ctx iris.Context) {
    // 获取所有上传的文件
    files := ctx.UploadFiles()
    if len(files) == 0 {
        ctx.StatusCode(iris.StatusBadRequest)
        ctx.JSON(iris.Map{"error": "没有上传文件"})
        return
    }
    
    var uploadedFiles []iris.Map
    var errors []iris.Map
    
    for _, file := range files {
        // 验证文件
        if err := validateUploadedFile(file); err != nil {
            errors = append(errors, iris.Map{
                "filename": file.Filename,
                "error": err.Error(),
            })
            continue
        }
        
        // 保存文件
        filename := generateUniqueFilename(file.Filename)
        savePath := filepath.Join("uploads", filename)
        
        if err := saveUploadedFile(file.File, savePath); err != nil {
            errors = append(errors, iris.Map{
                "filename": file.Filename,
                "error": "文件保存失败: " + err.Error(),
            })
            continue
        }
        
        uploadedFiles = append(uploadedFiles, iris.Map{
            "filename": filename,
            "original_name": file.Filename,
            "size": file.Size,
            "content_type": file.Header.Get("Content-Type"),
            "url": "/uploads/" + filename,
        })
    }
    
    ctx.JSON(iris.Map{
        "message": "文件上传处理完成",
        "uploaded_files": uploadedFiles,
        "errors": errors,
        "total_uploaded": len(uploadedFiles),
        "total_errors": len(errors),
    })
}

func validateUploadedFile(file *multipart.FileHeader) error {
    // 验证文件大小
    maxSize := int64(10 << 20) // 10MB
    if file.Size > maxSize {
        return fmt.Errorf("文件大小超过限制: %d bytes", file.Size)
    }
    
    // 验证文件类型
    ext := strings.ToLower(filepath.Ext(file.Filename))
    allowedExts := []string{".jpg", ".jpeg", ".png", ".gif", ".svg", ".pdf", ".txt", ".json"}
    
    if !contains(allowedExts, ext) {
        return fmt.Errorf("不支持的文件扩展名: %s", ext)
    }
    
    return nil
}
```

## 文件下载处理

### 1. 基本文件下载

```go
func fileDownloadHandler(ctx iris.Context) {
    filename := ctx.Params().Get("filename")
    
    // 安全检查：防止路径遍历
    if strings.Contains(filename, "..") || strings.Contains(filename, "/") {
        ctx.StatusCode(iris.StatusBadRequest)
        ctx.JSON(iris.Map{"error": "无效的文件名"})
        return
    }
    
    filepath := filepath.Join("downloads", filename)
    
    // 检查文件是否存在
    if _, err := os.Stat(filepath); os.IsNotExist(err) {
        ctx.StatusCode(iris.StatusNotFound)
        ctx.JSON(iris.Map{"error": "文件不存在"})
        return
    }
    
    // 设置下载头
    ctx.Header("Content-Disposition", fmt.Sprintf("attachment; filename=%s", filename))
    ctx.Header("Content-Type", "application/octet-stream")
    ctx.Header("Cache-Control", "no-cache")
    
    // 发送文件
    ctx.SendFile(filepath)
}
```

### 2. 断点续传下载

```go
func resumableDownloadHandler(ctx iris.Context) {
    filename := ctx.Params().Get("filename")
    filepath := filepath.Join("downloads", filename)
    
    // 检查文件是否存在
    fileInfo, err := os.Stat(filepath)
    if os.IsNotExist(err) {
        ctx.StatusCode(iris.StatusNotFound)
        ctx.JSON(iris.Map{"error": "文件不存在"})
        return
    }
    
    // 支持范围请求
    ctx.Header("Accept-Ranges", "bytes")
    
    // 处理范围请求
    rangeHeader := ctx.GetHeader("Range")
    if rangeHeader != "" {
        // 解析范围头
        ranges := strings.Split(strings.TrimPrefix(rangeHeader, "bytes="), "-")
        start, _ := strconv.ParseInt(ranges[0], 10, 64)
        end := fileInfo.Size() - 1
        
        if len(ranges) > 1 && ranges[1] != "" {
            end, _ = strconv.ParseInt(ranges[1], 10, 64)
        }
        
        // 设置部分内容响应头
        ctx.StatusCode(iris.StatusPartialContent)
        ctx.Header("Content-Range", fmt.Sprintf("bytes %d-%d/%d", start, end, fileInfo.Size()))
        ctx.Header("Content-Length", fmt.Sprintf("%d", end-start+1))
        
        // 发送文件内容
        file, err := os.Open(filepath)
        if err != nil {
            ctx.StatusCode(iris.StatusInternalServerError)
            return
        }
        defer file.Close()
        
        file.Seek(start, 0)
        io.CopyN(ctx.ResponseWriter(), file, end-start+1)
    } else {
        // 发送完整文件
        ctx.Header("Content-Length", fmt.Sprintf("%d", fileInfo.Size()))
        ctx.SendFile(filepath)
    }
}
```

## CDN 集成

### 1. 多 CDN 支持

```go
type CDNConfig struct {
    Domains []string
    Default string
    Weight  []int
}

func setupCDN(app *iris.Application) {
    config := CDNConfig{
        Domains: []string{
            "https://cdn1.example.com",
            "https://cdn2.example.com",
            "https://cdn3.example.com",
        },
        Default: "https://cdn1.example.com",
        Weight:  []int{1, 1, 1}, // 权重
    }
    
    // CDN 中间件
    cdnMiddleware := func(ctx iris.Context) {
        path := ctx.Path()
        
        // 只对静态资源应用 CDN
        if !strings.HasPrefix(path, "/static/") {
            ctx.Next()
            return
        }
        
        // 选择 CDN 域名
        cdnDomain := selectCDNDomain(config)
        
        // 重定向到 CDN
        if cdnDomain != "" {
            redirectURL := cdnDomain + path
            ctx.Redirect(redirectURL, iris.StatusMovedPermanently)
            return
        }
        
        ctx.Next()
    }
    
    app.UseRouter(cdnMiddleware)
}

func selectCDNDomain(config CDNConfig) string {
    totalWeight := 0
    for _, weight := range config.Weight {
        totalWeight += weight
    }
    
    random := rand.Intn(totalWeight)
    currentWeight := 0
    
    for i, weight := range config.Weight {
        currentWeight += weight
        if random < currentWeight {
            return config.Domains[i]
        }
    }
    
    return config.Default
}
```

### 2. 本地回退

```go
func setupCDNFallback(app *iris.Application) {
    // CDN 失败时的本地回退中间件
    fallbackMiddleware := func(ctx iris.Context) {
        path := ctx.Path()
        
        // 检查是否是 CDN 请求失败
        if ctx.GetHeader("X-CDN-Fallback") == "true" {
            // 从本地服务文件
            localPath := strings.TrimPrefix(path, "/cdn")
            localFile := filepath.Join("static", localPath)
            
            if _, err := os.Stat(localFile); err == nil {
                ctx.SendFile(localFile)
                return
            }
        }
        
        ctx.Next()
    }
    
    app.UseRouter(fallbackMiddleware)
    
    // CDN 请求失败处理
    app.Get("/cdn/*", func(ctx iris.Context) {
        path := ctx.Path()
        
        // 尝试从本地服务
        localPath := strings.TrimPrefix(path, "/cdn")
        localFile := filepath.Join("static", localPath)
        
        if _, err := os.Stat(localFile); err != nil {
            ctx.StatusCode(iris.StatusNotFound)
            ctx.JSON(iris.Map{"error": "文件不存在"})
            return
        }
        
        ctx.SendFile(localFile)
    })
}
```

## 性能优化

### 1. 文件压缩

```go
func setupCompression(app *iris.Application) {
    // 全局压缩中间件
    compressionMiddleware := func(ctx iris.Context) {
        // 检查客户端是否支持压缩
        acceptEncoding := ctx.GetHeader("Accept-Encoding")
        if !strings.Contains(acceptEncoding, "gzip") {
            ctx.Next()
            return
        }
        
        // 只对特定文件类型启用压缩
        path := ctx.Path()
        compressibleExts := []string{".html", ".css", ".js", ".json", ".xml", ".txt"}
        
        shouldCompress := false
        for _, ext := range compressibleExts {
            if strings.HasSuffix(path, ext) {
                shouldCompress = true
                break
            }
        }
        
        if shouldCompress {
            ctx.Gzip(true)
        }
        
        ctx.Next()
    }
    
    app.UseRouter(compressionMiddleware)
}
```

### 2. 内存缓存

```go
func setupMemoryCache(app *iris.Application) {
    // 内存缓存中间件
    type cacheEntry struct {
        data         []byte
        contentType  string
        lastModified time.Time
        etag         string
    }
    
    cache := make(map[string]*cacheEntry)
    var mutex sync.RWMutex
    
    cacheMiddleware := func(ctx iris.Context) {
        path := ctx.Path()
        
        // 只缓存静态文件
        if !strings.HasPrefix(path, "/static/") {
            ctx.Next()
            return
        }
        
        // 检查缓存
        mutex.RLock()
        if entry, exists := cache[path]; exists {
            // 检查 If-Modified-Since
            ifModifiedSince := ctx.GetHeader("If-Modified-Since")
            if ifModifiedSince != "" {
                ifModTime, _ := time.Parse(time.RFC1123, ifModifiedSince)
                if !entry.lastModified.After(ifModTime) {
                    ctx.StatusCode(iris.StatusNotModified)
                    mutex.RUnlock()
                    return
                }
            }
            
            // 检查 ETag
            ifNoneMatch := ctx.GetHeader("If-None-Match")
            if ifNoneMatch == entry.etag {
                ctx.StatusCode(iris.StatusNotModified)
                mutex.RUnlock()
                return
            }
            
            // 返回缓存内容
            ctx.ContentType(entry.contentType)
            ctx.Header("Last-Modified", entry.lastModified.Format(time.RFC1123))
            ctx.Header("ETag", entry.etag)
            ctx.Header("Cache-Control", "public, max-age=3600")
            ctx.Write(entry.data)
            mutex.RUnlock()
            return
        }
        mutex.RUnlock()
        
        // 缓存未命中，继续处理
        ctx.Next()
        
        // 缓存响应（简化处理）
        // 实际实现需要更复杂的逻辑来捕获响应
    }
    
    app.UseRouter(cacheMiddleware)
}
```

## 最佳实践

### 1. 目录结构组织

```
static/
├── css/           # CSS 文件
├── js/            # JavaScript 文件
├── images/        # 图片文件
├── fonts/         # 字体文件
├── icons/         # 图标文件
├── uploads/       # 用户上传文件
├── downloads/     # 可下载文件
└── assets/        # 其他资源文件
```

### 2. 文件命名规范

```go
// 版本化文件名
func versionedFilename(filename, version string) string {
    ext := filepath.Ext(filename)
    name := strings.TrimSuffix(filename, ext)
    return fmt.Sprintf("%s.%s%s", name, version, ext)
}

// 哈希文件名（用于缓存破坏）
func hashedFilename(filename string) string {
    data, err := os.ReadFile(filename)
    if err != nil {
        return filename
    }
    
    hash := sha256.Sum256(data)
    hashStr := hex.EncodeToString(hash[:8])
    
    ext := filepath.Ext(filename)
    name := strings.TrimSuffix(filename, ext)
    
    return fmt.Sprintf("%s.%s%s", name, hashStr, ext)
}
```

### 3. 安全检查

```go
func securityChecks(filename string) error {
    // 防止路径遍历
    if strings.Contains(filename, "..") {
        return fmt.Errorf("路径遍历攻击检测")
    }
    
    // 防止绝对路径
    if filepath.IsAbs(filename) {
        return fmt.Errorf("绝对路径不允许")
    }
    
    // 检查文件扩展名
    ext := strings.ToLower(filepath.Ext(filename))
    dangerousExts := []string{".php", ".asp", ".aspx", ".jsp", ".exe", ".bat", ".cmd", ".sh"}
    
    for _, dangerous := range dangerousExts {
        if ext == dangerous {
            return fmt.Errorf("危险的文件扩展名: %s", ext)
        }
    }
    
    return nil
}
```

## 下一步

现在您已经掌握了静态文件服务的各种技巧，建议继续学习：

1. [模板引擎](./07-模板引擎.md) - 掌握模板渲染
2. [数据库集成](./08-数据库集成.md) - 学习数据库操作
3. [身份验证](./09-身份验证.md) - 掌握认证授权

## 相关资源

- [Iris 静态文件文档](https://iris-go.com/handlers#static-files)
- [HTTP 缓存控制](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching)
- [Content Delivery Network](https://en.wikipedia.org/wiki/Content_delivery_network)