# 10 - 错误处理

## 错误处理概述

错误处理是构建健壮 Web 应用的关键部分。Iris 提供了灵活的错误处理机制，包括全局错误处理、路由级错误处理、中间件错误处理等。本项目实现了统一的错误处理系统。

## 错误类型定义

### 1. 自定义错误类型

```go
package errors

import (
    "fmt"
    "net/http"
)

// AppError 应用错误类型
type AppError struct {
    Code       int                    `json:"code"`        // HTTP 状态码
    Message    string                 `json:"message"`     // 错误消息
    Details    string                 `json:"details"`     // 详细错误信息
    Errors     map[string]interface{} `json:"errors"`      // 字段级错误
    Stack      string                 `json:"stack"`       // 错误堆栈
    RequestID  string                 `json:"request_id"`  // 请求ID
    Timestamp  string                 `json:"timestamp"`   // 错误时间
    Internal   error                  `json:"-"`           // 内部错误（不序列化）
}

// Error 实现 error 接口
func (e *AppError) Error() string {
    if e.Details != "" {
        return fmt.Sprintf("%s: %s", e.Message, e.Details)
    }
    return e.Message
}

// Unwrap 支持错误链
func (e *AppError) Unwrap() error {
    return e.Internal
}

// NewAppError 创建应用错误
func NewAppError(code int, message string) *AppError {
    return &AppError{
        Code:      code,
        Message:   message,
        Timestamp: getCurrentTimestamp(),
    }
}

// NewAppErrorWithDetails 创建带详细信息的应用错误
func NewAppErrorWithDetails(code int, message, details string) *AppError {
    return &AppError{
        Code:      code,
        Message:   message,
        Details:   details,
        Timestamp: getCurrentTimestamp(),
    }
}

// NewAppErrorWithInternal 创建带内部错误的应用错误
func NewAppErrorWithInternal(code int, message string, internal error) *AppError {
    return &AppError{
        Code:      code,
        Message:   message,
        Details:   internal.Error(),
        Stack:     getStackTrace(),
        Timestamp: getCurrentTimestamp(),
        Internal:  internal,
    }
}

// NewAppErrorWithValidation 创建验证错误
func NewAppErrorWithValidation(message string, errors map[string]interface{}) *AppError {
    return &AppError{
        Code:      http.StatusBadRequest,
        Message:   message,
        Errors:    errors,
        Timestamp: getCurrentTimestamp(),
    }
}

// SetRequestID 设置请求ID
func (e *AppError) SetRequestID(requestID string) *AppError {
    e.RequestID = requestID
    return e
}

// SetStack 设置错误堆栈
func (e *AppError) SetStack(stack string) *AppError {
    e.Stack = stack
    return e
}

// ToJSON 转换为 JSON 格式
func (e *AppError) ToJSON() map[string]interface{} {
    result := map[string]interface{}{
        "code":      e.Code,
        "message":   e.Message,
        "timestamp": e.Timestamp,
    }
    
    if e.Details != "" {
        result["details"] = e.Details
    }
    
    if e.Errors != nil {
        result["errors"] = e.Errors
    }
    
    if e.RequestID != "" {
        result["request_id"] = e.RequestID
    }
    
    // 在开发环境中包含堆栈信息
    if isDevelopment() && e.Stack != "" {
        result["stack"] = e.Stack
    }
    
    return result
}

// 预定义错误类型
var (
    // 400 错误
    ErrBadRequest          = NewAppError(http.StatusBadRequest, "请求参数错误")
    ErrInvalidInput        = NewAppError(http.StatusBadRequest, "输入数据无效")
    ErrValidationFailed    = NewAppError(http.StatusBadRequest, "数据验证失败")
    ErrMissingParameter    = NewAppError(http.StatusBadRequest, "缺少必需参数")
    ErrInvalidFormat       = NewAppError(http.StatusBadRequest, "数据格式错误")
    
    // 401 错误
    ErrUnauthorized        = NewAppError(http.StatusUnauthorized, "未授权访问")
    ErrInvalidCredentials  = NewAppError(http.StatusUnauthorized, "用户名或密码错误")
    ErrTokenExpired        = NewAppError(http.StatusUnauthorized, "认证令牌已过期")
    ErrInvalidToken        = NewAppError(http.StatusUnauthorized, "无效的认证令牌")
    ErrMissingToken        = NewAppError(http.StatusUnauthorized, "缺少认证令牌")
    
    // 403 错误
    ErrForbidden           = NewAppError(http.StatusForbidden, "权限不足")
    ErrRoleRequired        = NewAppError(http.StatusForbidden, "需要特定角色权限")
    ErrResourceForbidden   = NewAppError(http.StatusForbidden, "资源访问被禁止")
    
    // 404 错误
    ErrNotFound            = NewAppError(http.StatusNotFound, "资源不存在")
    ErrUserNotFound        = NewAppError(http.StatusNotFound, "用户不存在")
    ErrPostNotFound        = NewAppError(http.StatusNotFound, "文章不存在")
    ErrCommentNotFound     = NewAppError(http.StatusNotFound, "评论不存在")
    
    // 409 错误
    ErrConflict            = NewAppError(http.StatusConflict, "资源冲突")
    ErrUserExists          = NewAppError(http.StatusConflict, "用户已存在")
    ErrEmailExists         = NewAppError(http.StatusConflict, "邮箱已存在")
    ErrUsernameExists      = NewAppError(http.StatusConflict, "用户名已存在")
    
    // 422 错误
    ErrUnprocessableEntity = NewAppError(http.StatusUnprocessableEntity, "请求无法处理")
    ErrInvalidState        = NewAppError(http.StatusUnprocessableEntity, "资源状态无效")
    
    // 429 错误
    ErrTooManyRequests     = NewAppError(http.StatusTooManyRequests, "请求过于频繁")
    
    // 500 错误
    ErrInternalServer      = NewAppError(http.StatusInternalServerError, "服务器内部错误")
    ErrDatabaseError       = NewAppError(http.StatusInternalServerError, "数据库操作失败")
    ErrExternalService     = NewAppError(http.StatusInternalServerError, "外部服务错误")
    ErrFileOperation       = NewAppError(http.StatusInternalServerError, "文件操作失败")
    
    // 502 错误
    ErrBadGateway          = NewAppError(http.StatusBadGateway, "网关错误")
    
    // 503 错误
    ErrServiceUnavailable  = NewAppError(http.StatusServiceUnavailable, "服务不可用")
    ErrMaintenance         = NewAppError(http.StatusServiceUnavailable, "系统维护中")
    
    // 504 错误
    ErrGatewayTimeout      = NewAppError(http.StatusGatewayTimeout, "网关超时")
)
```

### 2. 错误工具函数

```go
package utils

import (
    "runtime/debug"
    "strings"
    "time"
)

// getCurrentTimestamp 获取当前时间戳
func getCurrentTimestamp() string {
    return time.Now().Format("2006-01-02 15:04:05")
}

// getStackTrace 获取错误堆栈
func getStackTrace() string {
    stack := debug.Stack()
    return string(stack)
}

// isDevelopment 判断是否为开发环境
func isDevelopment() bool {
    // 这里可以根据环境变量或配置判断
    return true // 简化实现
}

// WrapError 包装错误
func WrapError(err error, message string) *AppError {
    if err == nil {
        return nil
    }
    
    if appErr, ok := err.(*AppError); ok {
        return appErr
    }
    
    return NewAppErrorWithInternal(http.StatusInternalServerError, message, err)
}

// WrapErrorWithCode 带状态码包装错误
func WrapErrorWithCode(err error, code int, message string) *AppError {
    if err == nil {
        return nil
    }
    
    if appErr, ok := err.(*AppError); ok {
        return appErr
    }
    
    return NewAppErrorWithInternal(code, message, err)
}

// IsAppError 判断是否为应用错误
func IsAppError(err error) (*AppError, bool) {
    if appErr, ok := err.(*AppError); ok {
        return appErr, true
    }
    return nil, false
}

// GetErrorCode 获取错误代码
func GetErrorCode(err error) int {
    if appErr, ok := err.(*AppError); ok {
        return appErr.Code
    }
    return http.StatusInternalServerError
}

// GetErrorMessage 获取错误消息
func GetErrorMessage(err error) string {
    if appErr, ok := err.(*AppError); ok {
        return appErr.Message
    }
    return "未知错误"
}

// FormatValidationError 格式化验证错误
func FormatValidationError(field, message string) map[string]interface{} {
    return map[string]interface{}{
        "field":   field,
        "message": message,
    }
}

// CombineValidationErrors 合并验证错误
func CombineValidationErrors(errors map[string]string) map[string]interface{} {
    result := make(map[string]interface{})
    for field, message := range errors {
        result[field] = map[string]interface{}{
            "field":   field,
            "message": message,
        }
    }
    return result
}

// SanitizeError 清理错误信息（用于对外输出）
func SanitizeError(err error) string {
    if appErr, ok := err.(*AppError); ok {
        if isDevelopment() {
            return appErr.Error()
        }
        return appErr.Message
    }
    
    if isDevelopment() {
        return err.Error()
    }
    
    return "服务器内部错误"
}
```

## 错误处理中间件

### 1. 全局错误处理中间件

```go
package middleware

import (
    "log"
    "runtime/debug"
    "strings"
    
    "iris-cn-sample-project/errors"
    "iris-cn-sample-project/utils"
    
    "github.com/kataras/iris/v12"
)

// ErrorHandler 全局错误处理中间件
func ErrorHandler() iris.Handler {
    return func(ctx iris.Context) {
        defer func() {
            if err := recover(); err != nil {
                handlePanic(ctx, err)
            }
        }()
        
        ctx.Next()
        
        // 检查是否有错误存储在上下文中
        if err := ctx.Values().Get("error"); err != nil {
            handleError(ctx, err.(error))
        }
    }
}

// handlePanic 处理 panic
func handlePanic(ctx iris.Context, recovered interface{}) {
    // 记录 panic 信息
    logPanic(ctx, recovered)
    
    // 创建错误响应
    appErr := errors.NewAppErrorWithInternal(
        iris.StatusInternalServerError,
        "服务器内部错误",
        fmt.Errorf("%v", recovered),
    )
    appErr.SetStack(string(debug.Stack()))
    appErr.SetRequestID(getRequestID(ctx))
    
    // 返回错误响应
    sendErrorResponse(ctx, appErr)
}

// handleError 处理错误
func handleError(ctx iris.Context, err error) {
    // 获取请求ID
    requestID := getRequestID(ctx)
    
    // 判断错误类型
    switch e := err.(type) {
    case *errors.AppError:
        // 应用错误
        e.SetRequestID(requestID)
        sendErrorResponse(ctx, e)
        
    case *json.UnmarshalTypeError:
        // JSON 解析错误
        appErr := errors.NewAppErrorWithDetails(
            iris.StatusBadRequest,
            "JSON 数据格式错误",
            e.Error(),
        )
        appErr.SetRequestID(requestID)
        sendErrorResponse(ctx, appErr)
        
    case *strconv.NumError:
        // 数字转换错误
        appErr := errors.NewAppErrorWithDetails(
            iris.StatusBadRequest,
            "数字格式错误",
            e.Error(),
        )
        appErr.SetRequestID(requestID)
        sendErrorResponse(ctx, appErr)
        
    case *time.ParseError:
        // 时间解析错误
        appErr := errors.NewAppErrorWithDetails(
            iris.StatusBadRequest,
            "时间格式错误",
            e.Error(),
        )
        appErr.SetRequestID(requestID)
        sendErrorResponse(ctx, appErr)
        
    case interface{ Validate() error }:
        // 自定义验证错误
        if validationErr := e.Validate(); validationErr != nil {
            appErr := errors.NewAppErrorWithDetails(
                iris.StatusBadRequest,
                "数据验证失败",
                validationErr.Error(),
            )
            appErr.SetRequestID(requestID)
            sendErrorResponse(ctx, appErr)
        } else {
            sendErrorResponse(ctx, err)
        }
        
    default:
        // 其他错误
        appErr := utils.WrapErrorWithCode(err, iris.StatusInternalServerError, "服务器内部错误")
        if appErr != nil {
            appErr.SetRequestID(requestID)
            sendErrorResponse(ctx, appErr)
        }
    }
}

// sendErrorResponse 发送错误响应
func sendErrorResponse(ctx iris.Context, appErr *errors.AppError) {
    // 设置状态码
    ctx.StatusCode(appErr.Code)
    
    // 根据请求类型返回不同格式的响应
    accept := ctx.GetHeader("Accept")
    
    if strings.Contains(accept, "text/html") {
        // HTML 错误页面
        sendHTMLErrorResponse(ctx, appErr)
    } else {
        // JSON 错误响应
        sendJSONErrorResponse(ctx, appErr)
    }
}

// sendJSONErrorResponse 发送 JSON 错误响应
func sendJSONErrorResponse(ctx iris.Context, appErr *errors.AppError) {
    ctx.JSON(appErr.ToJSON())
}

// sendHTMLErrorResponse 发送 HTML 错误页面
func sendHTMLErrorResponse(ctx iris.Context, appErr *errors.AppError) {
    // 设置模板数据
    ctx.ViewData("title", "错误页面")
    ctx.ViewData("error", appErr)
    ctx.ViewData("code", appErr.Code)
    ctx.ViewData("message", appErr.Message)
    
    // 根据状态码选择模板
    switch appErr.Code {
    case iris.StatusNotFound:
        ctx.View("errors/404.html")
    case iris.StatusForbidden:
        ctx.View("errors/403.html")
    case iris.StatusUnauthorized:
        ctx.View("errors/401.html")
    case iris.StatusInternalServerError:
        ctx.View("errors/500.html")
    default:
        ctx.View("errors/error.html")
    }
}

// logPanic 记录 panic 信息
func logPanic(ctx iris.Context, recovered interface{}) {
    log.Printf("PANIC RECOVERED: %v", recovered)
    log.Printf("Request: %s %s", ctx.Method(), ctx.Path())
    log.Printf("RemoteAddr: %s", ctx.RemoteAddr())
    log.Printf("UserAgent: %s", ctx.GetHeader("User-Agent"))
    log.Printf("Stack: %s", string(debug.Stack()))
}

// getRequestID 获取请求ID
func getRequestID(ctx iris.Context) string {
    if requestID := ctx.Values().GetString("request_id"); requestID != "" {
        return requestID
    }
    return ctx.GetHeader("X-Request-ID")
}
```

### 2. 业务错误处理

```go
package services

import (
    "fmt"
    
    "iris-cn-sample-project/database"
    "iris-cn-sample-project/errors"
    "iris-cn-sample-project/models"
    
    "gorm.io/gorm"
)

// ErrorHandler 业务错误处理器
type ErrorHandler struct {
    db *gorm.DB
}

// NewErrorHandler 创建错误处理器实例
func NewErrorHandler() *ErrorHandler {
    return &ErrorHandler{
        db: database.GetDB(),
    }
}

// HandleDatabaseError 处理数据库错误
func (h *ErrorHandler) HandleDatabaseError(err error) error {
    if err == nil {
        return nil
    }
    
    switch {
    case errors.Is(err, gorm.ErrRecordNotFound):
        return errors.ErrNotFound
        
    case errors.Is(err, gorm.ErrInvalidTransaction):
        return errors.NewAppErrorWithDetails(
            iris.StatusInternalServerError,
            "数据库事务错误",
            err.Error(),
        )
        
    case strings.Contains(err.Error(), "duplicate"):
        return handleDuplicateError(err)
        
    case strings.Contains(err.Error(), "foreign key"):
        return errors.NewAppErrorWithDetails(
            iris.StatusBadRequest,
            "外键约束错误",
            err.Error(),
        )
        
    case strings.Contains(err.Error(), "check constraint"):
        return errors.NewAppErrorWithDetails(
            iris.StatusBadRequest,
            "数据约束错误",
            err.Error(),
        )
        
    default:
        return errors.NewAppErrorWithInternal(
            iris.StatusInternalServerError,
            "数据库操作失败",
            err,
        )
    }
}

// handleDuplicateError 处理重复数据错误
func handleDuplicateError(err error) error {
    errorMsg := err.Error()
    
    switch {
    case strings.Contains(errorMsg, "users.username"):
        return errors.ErrUsernameExists
        
    case strings.Contains(errorMsg, "users.email"):
        return errors.ErrEmailExists
        
    case strings.Contains(errorMsg, "posts.slug"):
        return errors.NewAppErrorWithDetails(
            iris.StatusConflict,
            "文章标识符已存在",
            "请修改文章标题或标识符",
        )
        
    default:
        return errors.ErrConflict
    }
}

// HandleValidationError 处理验证错误
func (h *ErrorHandler) HandleValidationError(err error, field string) error {
    return errors.NewAppErrorWithValidation(
        "数据验证失败",
        map[string]interface{}{
            field: map[string]interface{}{
                "field":   field,
                "message": err.Error(),
            },
        },
    )
}

// HandleExternalServiceError 处理外部服务错误
func (h *ErrorHandler) HandleExternalServiceError(serviceName string, err error) error {
    return errors.NewAppErrorWithDetails(
        iris.StatusInternalServerError,
        fmt.Sprintf("外部服务 %s 错误", serviceName),
        err.Error(),
    )
}

// HandleFileError 处理文件操作错误
func (h *ErrorHandler) HandleFileError(operation string, err error) error {
    switch {
    case strings.Contains(err.Error(), "no such file"):
        return errors.NewAppErrorWithDetails(
            iris.StatusNotFound,
            "文件不存在",
            fmt.Sprintf("%s: %s", operation, err.Error()),
        )
        
    case strings.Contains(err.Error(), "permission denied"):
        return errors.NewAppErrorWithDetails(
            iris.StatusForbidden,
            "文件权限不足",
            fmt.Sprintf("%s: %s", operation, err.Error()),
        )
        
    case strings.Contains(err.Error(), "disk full"):
        return errors.NewAppErrorWithDetails(
            iris.StatusInternalServerError,
            "磁盘空间不足",
            fmt.Sprintf("%s: %s", operation, err.Error()),
        )
        
    default:
        return errors.NewAppErrorWithInternal(
            iris.StatusInternalServerError,
            "文件操作失败",
            err,
        )
    }
}

// WrapServiceError 包装服务错误
func (h *ErrorHandler) WrapServiceError(err error, serviceName string) error {
    if err == nil {
        return nil
    }
    
    if appErr, ok := err.(*errors.AppError); ok {
        return appErr
    }
    
    return errors.NewAppErrorWithInternal(
        iris.StatusInternalServerError,
        fmt.Sprintf("%s 服务错误", serviceName),
        err,
    )
}
```

## 错误恢复机制

### 1. 恢复中间件

```go
package middleware

import (
    "log"
    "runtime/debug"
    "time"
    
    "iris-cn-sample-project/errors"
    
    "github.com/kataras/iris/v12"
)

// RecoveryMiddleware 恢复中间件
func RecoveryMiddleware() iris.Handler {
    return func(ctx iris.Context) {
        defer func() {
            if err := recover(); err != nil {
                // 记录 panic
                log.Printf("RECOVERY: Panic recovered: %v", err)
                log.Printf("RECOVERY: Stack trace:\n%s", debug.Stack())
                
                // 创建错误响应
                appErr := errors.NewAppErrorWithInternal(
                    iris.StatusInternalServerError,
                    "服务器内部错误",
                    fmt.Errorf("%v", err),
                )
                appErr.SetStack(string(debug.Stack()))
                
                // 发送错误响应
                sendErrorResponse(ctx, appErr)
            }
        }()
        
        ctx.Next()
    }
}

// CustomRecoveryMiddleware 自定义恢复中间件
func CustomRecoveryMiddleware(handler func(ctx iris.Context, err interface{})) iris.Handler {
    return func(ctx iris.Context) {
        defer func() {
            if err := recover(); err != nil {
                // 调用自定义处理器
                if handler != nil {
                    handler(ctx, err)
                } else {
                    // 默认处理
                    log.Printf("RECOVERY: Panic recovered: %v", err)
                    appErr := errors.NewAppErrorWithInternal(
                        iris.StatusInternalServerError,
                        "服务器内部错误",
                        fmt.Errorf("%v", err),
                    )
                    sendErrorResponse(ctx, appErr)
                }
            }
        }()
        
        ctx.Next()
    }
}

// TimeoutMiddleware 超时处理中间件
func TimeoutMiddleware(timeout time.Duration) iris.Handler {
    return func(ctx iris.Context) {
        // 创建带超时的上下文
        timeoutCtx, cancel := context.WithTimeout(ctx.Request().Context(), timeout)
        defer cancel()
        
        // 替换请求上下文
        ctx.Request().WithContext(timeoutCtx)
        
        // 监听超时
        done := make(chan struct{})
        go func() {
            defer func() {
                if err := recover(); err != nil {
                    log.Printf("TIMEOUT: Panic in goroutine: %v", err)
                }
                close(done)
            }()
            
            ctx.Next()
        }()
        
        select {
        case <-done:
            // 正常完成
        case <-timeoutCtx.Done():
            // 超时处理
            appErr := errors.ErrGatewayTimeout
            appErr.Details = "请求处理超时"
            sendErrorResponse(ctx, appErr)
        }
    }
}

// CircuitBreakerMiddleware 熔断器中间件
type CircuitBreaker struct {
    failures    int
    maxFailures int
    state       string // "closed", "open", "half-open"
    lastFailure time.Time
    timeout     time.Duration
    mutex       sync.RWMutex
}

// NewCircuitBreaker 创建熔断器
func NewCircuitBreaker(maxFailures int, timeout time.Duration) *CircuitBreaker {
    return &CircuitBreaker{
        maxFailures: maxFailures,
        state:       "closed",
        timeout:     timeout,
    }
}

// AllowRequest 检查是否允许请求
func (cb *CircuitBreaker) AllowRequest() bool {
    cb.mutex.RLock()
    defer cb.mutex.RUnlock()
    
    switch cb.state {
    case "closed":
        return true
    case "open":
        return time.Since(cb.lastFailure) > cb.timeout
    case "half-open":
        return true
    default:
        return false
    }
}

// RecordSuccess 记录成功
func (cb *CircuitBreaker) RecordSuccess() {
    cb.mutex.Lock()
    defer cb.mutex.Unlock()
    
    cb.failures = 0
    cb.state = "closed"
}

// RecordFailure 记录失败
func (cb *CircuitBreaker) RecordFailure() {
    cb.mutex.Lock()
    defer cb.mutex.Unlock()
    
    cb.failures++
    cb.lastFailure = time.Now()
    
    if cb.failures >= cb.maxFailures {
        cb.state = "open"
    }
}

// CircuitBreakerMiddleware 熔断器中间件
func (cb *CircuitBreaker) CircuitBreakerMiddleware() iris.Handler {
    return func(ctx iris.Context) {
        if !cb.AllowRequest() {
            appErr := errors.ErrServiceUnavailable
            appErr.Details = "服务熔断，请稍后重试"
            sendErrorResponse(ctx, appErr)
            return
        }
        
        // 执行请求
        ctx.Next()
        
        // 根据响应状态码记录结果
        if ctx.GetStatusCode() >= 500 {
            cb.RecordFailure()
        } else {
            cb.RecordSuccess()
        }
    }
}
```

## 错误日志记录

### 1. 结构化日志

```go
package logging

import (
    "encoding/json"
    "fmt"
    "log"
    "os"
    "time"
    
    "iris-cn-sample-project/errors"
)

// ErrorLogger 错误日志记录器
type ErrorLogger struct {
    logger *log.Logger
    file   *os.File
}

// NewErrorLogger 创建错误日志记录器
func NewErrorLogger(logFile string) (*ErrorLogger, error) {
    file, err := os.OpenFile(logFile, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
    if err != nil {
        return nil, fmt.Errorf("打开日志文件失败: %v", err)
    }
    
    logger := log.New(file, "", log.LstdFlags|log.Lshortfile)
    
    return &ErrorLogger{
        logger: logger,
        file:   file,
    }, nil
}

// LogError 记录错误
func (l *ErrorLogger) LogError(err error, ctx map[string]interface{}) {
    if err == nil {
        return
    }
    
    // 构建日志条目
    logEntry := map[string]interface{}{
        "timestamp": time.Now().Format(time.RFC3339),
        "level":     "ERROR",
        "message":   err.Error(),
        "context":   ctx,
    }
    
    // 如果是应用错误，添加更多字段
    if appErr, ok := err.(*errors.AppError); ok {
        logEntry["code"] = appErr.Code
        logEntry["details"] = appErr.Details
        logEntry["request_id"] = appErr.RequestID
        logEntry["stack"] = appErr.Stack
    }
    
    // 转换为 JSON 并记录
    jsonEntry, _ := json.Marshal(logEntry)
    l.logger.Printf("%s", string(jsonEntry))
}

// LogPanic 记录 panic
func (l *ErrorLogger) LogPanic(recovered interface{}, ctx map[string]interface{}) {
    logEntry := map[string]interface{}{
        "timestamp": time.Now().Format(time.RFC3339),
        "level":     "PANIC",
        "message":   fmt.Sprintf("%v", recovered),
        "context":   ctx,
    }
    
    jsonEntry, _ := json.Marshal(logEntry)
    l.logger.Printf("%s", string(jsonEntry))
}

// Close 关闭日志文件
func (l *ErrorLogger) Close() error {
    if l.file != nil {
        return l.file.Close()
    }
    return nil
}

// ErrorContext 错误上下文
type ErrorContext struct {
    Method     string                 `json:"method"`
    Path       string                 `json:"path"`
    Query      string                 `json:"query"`
    RemoteAddr string                 `json:"remote_addr"`
    UserAgent  string                 `json:"user_agent"`
    UserID     uint                   `json:"user_id,omitempty"`
    RequestID  string                 `json:"request_id,omitempty"`
    Headers    map[string]string      `json:"headers,omitempty"`
    Body       interface{}            `json:"body,omitempty"`
    Metadata   map[string]interface{} `json:"metadata,omitempty"`
}

// NewErrorContext 从 Iris 上下文创建错误上下文
func NewErrorContext(ctx iris.Context) *ErrorContext {
    errorCtx := &ErrorContext{
        Method:     ctx.Method(),
        Path:       ctx.Path(),
        Query:      ctx.URLParams().Encode(),
        RemoteAddr: ctx.RemoteAddr(),
        UserAgent:  ctx.GetHeader("User-Agent"),
        Headers:    make(map[string]string),
        Metadata:   make(map[string]interface{}),
    }
    
    // 获取用户信息
    if userID := ctx.Values().GetUint("user_id"); userID > 0 {
        errorCtx.UserID = userID
    }
    
    // 获取请求ID
    if requestID := ctx.Values().GetString("request_id"); requestID != "" {
        errorCtx.RequestID = requestID
    }
    
    // 获取重要的请求头
    importantHeaders := []string{
        "Content-Type", "Accept", "Authorization",
        "X-Forwarded-For", "X-Real-IP", "X-Request-ID",
    }
    
    for _, header := range importantHeaders {
        if value := ctx.GetHeader(header); value != "" {
            errorCtx.Headers[header] = value
        }
    }
    
    return errorCtx
}

// AddMetadata 添加元数据
func (ec *ErrorContext) AddMetadata(key string, value interface{}) {
    if ec.Metadata == nil {
        ec.Metadata = make(map[string]interface{})
    }
    ec.Metadata[key] = value
}

// ToMap 转换为 map
func (ec *ErrorContext) ToMap() map[string]interface{} {
    result := map[string]interface{}{
        "method":      ec.Method,
        "path":        ec.Path,
        "query":       ec.Query,
        "remote_addr": ec.RemoteAddr,
        "user_agent":  ec.UserAgent,
        "headers":     ec.Headers,
    }
    
    if ec.UserID > 0 {
        result["user_id"] = ec.UserID
    }
    
    if ec.RequestID != "" {
        result["request_id"] = ec.RequestID
    }
    
    if ec.Body != nil {
        result["body"] = ec.Body
    }
    
    if len(ec.Metadata) > 0 {
        result["metadata"] = ec.Metadata
    }
    
    return result
}
```

## 错误监控和告警

### 1. 错误监控

```go
package monitoring

import (
    "sync"
    "time"
    
    "iris-cn-sample-project/errors"
)

// ErrorMonitor 错误监控器
type ErrorMonitor struct {
    errors      map[string]*ErrorStats
    mutex       sync.RWMutex
    alertChan   chan *ErrorAlert
    stopChan    chan struct{}
}

// ErrorStats 错误统计
type ErrorStats struct {
    Count       int64     `json:"count"`
    LastOccur   time.Time  `json:"last_occur"`
    FirstOccur  time.Time  `json:"first_occur"`
    Rate        float64    `json:"rate"`
    WindowSize  time.Duration `json:"window_size"`
}

// ErrorAlert 错误告警
type ErrorAlert struct {
    ErrorType   string    `json:"error_type"`
    Count       int64     `json:"count"`
    Rate        float64   `json:"rate"`
    Threshold   float64   `json:"threshold"`
    Timestamp   time.Time `json:"timestamp"`
}

// NewErrorMonitor 创建错误监控器
func NewErrorMonitor() *ErrorMonitor {
    em := &ErrorMonitor{
        errors:    make(map[string]*ErrorStats),
        alertChan: make(chan *ErrorAlert, 100),
        stopChan:  make(chan struct{}),
    }
    
    // 启动监控协程
    go em.monitor()
    
    return em
}

// RecordError 记录错误
func (em *ErrorMonitor) RecordError(err error) {
    if err == nil {
        return
    }
    
    errorType := getErrorType(err)
    
    em.mutex.Lock()
    defer em.mutex.Unlock()
    
    stats, exists := em.errors[errorType]
    if !exists {
        stats = &ErrorStats{
            FirstOccur: time.Now(),
            WindowSize:  time.Minute,
        }
        em.errors[errorType] = stats
    }
    
    stats.Count++
    stats.LastOccur = time.Now()
    
    // 计算错误率
    stats.Rate = float64(stats.Count) / time.Since(stats.FirstOccur).Seconds()
    
    // 检查是否需要告警
    if stats.Rate > getErrorThreshold(errorType) {
        alert := &ErrorAlert{
            ErrorType: errorType,
            Count:     stats.Count,
            Rate:      stats.Rate,
            Threshold: getErrorThreshold(errorType),
            Timestamp: time.Now(),
        }
        
        select {
        case em.alertChan <- alert:
        default:
            // 告警通道满了，丢弃告警
        }
    }
}

// GetStats 获取错误统计
func (em *ErrorMonitor) GetStats() map[string]*ErrorStats {
    em.mutex.RLock()
    defer em.mutex.RUnlock()
    
    result := make(map[string]*ErrorStats)
    for k, v := range em.errors {
        result[k] = v
    }
    
    return result
}

// monitor 监控协程
func (em *ErrorMonitor) monitor() {
    ticker := time.NewTicker(time.Minute)
    defer ticker.Stop()
    
    for {
        select {
        case alert := <-em.alertChan:
            em.sendAlert(alert)
            
        case <-ticker.C:
            em.cleanupOldErrors()
            
        case <-em.stopChan:
            return
        }
    }
}

// sendAlert 发送告警
func (em *ErrorMonitor) sendAlert(alert *ErrorAlert) {
    // 这里可以实现各种告警方式
    log.Printf("ERROR ALERT: %s - Count: %d, Rate: %.2f/s, Threshold: %.2f/s",
        alert.ErrorType, alert.Count, alert.Rate, alert.Threshold)
    
    // 可以发送邮件、短信、Slack 等
}

// cleanupOldErrors 清理旧的错误统计
func (em *ErrorMonitor) cleanupOldErrors() {
    em.mutex.Lock()
    defer em.mutex.Unlock()
    
    cutoff := time.Now().Add(-time.Hour) // 保留1小时的数据
    
    for errorType, stats := range em.errors {
        if stats.LastOccur.Before(cutoff) {
            delete(em.errors, errorType)
        }
    }
}

// Stop 停止监控
func (em *ErrorMonitor) Stop() {
    close(em.stopChan)
}

// getErrorType 获取错误类型
func getErrorType(err error) string {
    if appErr, ok := err.(*errors.AppError); ok {
        return fmt.Sprintf("%d_%s", appErr.Code, appErr.Message)
    }
    return fmt.Sprintf("%T", err)
}

// getErrorThreshold 获取错误阈值
func getErrorThreshold(errorType string) float64 {
    // 可以根据错误类型设置不同的阈值
    thresholds := map[string]float64{
        "500_服务器内部错误": 10.0,
        "404_资源不存在":     50.0,
        "400_请求参数错误":    100.0,
    }
    
    if threshold, exists := thresholds[errorType]; exists {
        return threshold
    }
    
    return 5.0 // 默认阈值
}
```

## 最佳实践

### 1. 错误处理原则

- **统一性**: 使用统一的错误类型和格式
- **可追踪性**: 记录足够的上下文信息
- **安全性**: 不暴露敏感的内部信息
- **友好性**: 提供用户友好的错误消息
- **可恢复性**: 尽可能提供恢复建议

### 2. 错误分类

```go
// 错误分类
const (
    ErrorCategoryValidation = "validation"
    ErrorCategoryAuth       = "authentication"
    ErrorCategoryPermission = "permission"
    ErrorCategoryBusiness    = "business"
    ErrorCategoryExternal    = "external"
    ErrorCategorySystem      = "system"
)

// GetErrorCategory 获取错误分类
func GetErrorCategory(err error) string {
    if appErr, ok := err.(*errors.AppError); ok {
        switch appErr.Code {
        case iris.StatusBadRequest:
            return ErrorCategoryValidation
        case iris.StatusUnauthorized:
            return ErrorCategoryAuth
        case iris.StatusForbidden:
            return ErrorCategoryPermission
        case iris.StatusNotFound, iris.StatusConflict:
            return ErrorCategoryBusiness
        case iris.StatusBadGateway, iris.StatusServiceUnavailable, iris.StatusGatewayTimeout:
            return ErrorCategoryExternal
        default:
            return ErrorCategorySystem
        }
    }
    
    return ErrorCategorySystem
}
```

### 3. 错误恢复策略

```go
// RecoveryStrategy 恢复策略
type RecoveryStrategy interface {
    CanRecover(err error) bool
    Recover(err error) error
}

// DatabaseRecoveryStrategy 数据库恢复策略
type DatabaseRecoveryStrategy struct {
    maxRetries int
    retryDelay time.Duration
}

func (s *DatabaseRecoveryStrategy) CanRecover(err error) bool {
    // 检查是否为可恢复的数据库错误
    return strings.Contains(err.Error(), "connection") ||
           strings.Contains(err.Error(), "timeout")
}

func (s *DatabaseRecoveryStrategy) Recover(err error) error {
    // 实现重连逻辑
    time.Sleep(s.retryDelay)
    return nil
}
```

## 下一步

现在您已经掌握了错误处理的各种技巧，建议继续学习：

1. [部署运维](./11-部署运维.md) - 学习应用部署
2. [性能优化](./12-性能优化.md) - 掌握性能调优
3. [监控告警](./13-监控告警.md) - 学习系统监控

## 相关资源

- [Iris 错误处理文档](https://iris-go.com/context#error-handlers)
- [Go 错误处理最佳实践](https://blog.golang.org/error-handling-and-go)
- [OWASP 错误处理指南](https://owasp.org/www-project-proactive-controls/v3/en/c10-security-error-handling)