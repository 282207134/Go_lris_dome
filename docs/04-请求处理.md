# 04 - 请求处理

## 请求处理概述

Iris 提供了丰富的请求处理功能，可以轻松获取和解析各种类型的请求数据，包括查询参数、路径参数、请求头、请求体等。

## 获取请求信息

### 1. 基本请求信息

```go
func requestInfo(ctx iris.Context) {
    // 请求方法
    method := ctx.Method()
    
    // 请求路径
    path := ctx.Path()
    
    // 请求URL
    url := ctx.Request().URL.String()
    
    // 协议版本
    protocol := ctx.Request().Proto
    
    // 主机名
    host := ctx.Host()
    
    // 远程地址
    remoteAddr := ctx.RemoteAddr()
    
    // 用户代理
    userAgent := ctx.GetHeader("User-Agent")
    
    // 内容类型
    contentType := ctx.GetContentType()
    
    // 内容长度
    contentLength := ctx.GetContentLength()
    
    ctx.JSON(iris.Map{
        "method":        method,
        "path":          path,
        "url":           url,
        "protocol":      protocol,
        "host":          host,
        "remote_addr":   remoteAddr,
        "user_agent":    userAgent,
        "content_type":  contentType,
        "content_length": contentLength,
    })
}
```

### 2. 获取客户端IP

```go
func getClientIP(ctx iris.Context) string {
    // 尝试从 X-Forwarded-For 头获取
    xForwardedFor := ctx.GetHeader("X-Forwarded-For")
    if xForwardedFor != "" {
        // X-Forwarded-For 可能包含多个IP，取第一个
        ips := strings.Split(xForwardedFor, ",")
        if len(ips) > 0 {
            ip := strings.TrimSpace(ips[0])
            if ip != "" && ip != "unknown" {
                return ip
            }
        }
    }

    // 尝试从 X-Real-IP 头获取
    xRealIP := ctx.GetHeader("X-Real-IP")
    if xRealIP != "" {
        return strings.TrimSpace(xRealIP)
    }

    // 最后使用 RemoteAddr
    ip, _, err := net.SplitHostPort(ctx.RemoteAddr())
    if err != nil {
        return ctx.RemoteAddr()
    }
    return ip
}
```

## 查询参数处理

### 1. 基本查询参数

```go
func queryParameters(ctx iris.Context) {
    // 获取单个查询参数
    name := ctx.URLParam("name")
    page := ctx.URLParam("page")
    limit := ctx.URLParam("limit")
    
    // 带默认值的查询参数
    name = ctx.URLParamDefault("name", "Guest")
    page = ctx.URLParamDefault("page", "1")
    limit = ctx.URLParamDefault("limit", "10")
    
    // 获取所有查询参数
    allParams := ctx.URLParams()
    
    // 获取查询参数数组
    tags := ctx.URLParamsSlice("tags")
    categories := ctx.URLParamsSlice("categories")
    
    ctx.JSON(iris.Map{
        "name":       name,
        "page":       page,
        "limit":      limit,
        "all_params": allParams,
        "tags":       tags,
        "categories": categories,
    })
}
```

### 2. 类型化查询参数

```go
func typedQueryParams(ctx iris.Context) {
    // 字符串参数
    keyword := ctx.URLParam("keyword")
    
    // 整数参数
    page, err := ctx.URLParamInt("page")
    if err != nil {
        page = 1
    }
    
    // 带默认值的整数参数
    limit, _ := ctx.URLParamIntDefault("limit", 10)
    
    // 浮点数参数
    price, err := ctx.URLParamFloat64("price")
    if err != nil {
        price = 0.0
    }
    
    // 布尔参数
    active, _ := ctx.URLParamBool("active")
    
    // 时间参数
    date := ctx.URLParam("date")
    parsedDate, err := time.Parse("2006-01-02", date)
    
    ctx.JSON(iris.Map{
        "keyword": keyword,
        "page":    page,
        "limit":   limit,
        "price":   price,
        "active":  active,
        "date":    date,
        "parsed_date": parsedDate,
    })
}
```

## 路径参数处理

### 1. 基本路径参数

```go
func pathParameters(ctx iris.Context) {
    // 获取路径参数
    id := ctx.Params().Get("id")
    name := ctx.Params().Get("name")
    
    // 类型化路径参数
    userID, err := ctx.Params().GetInt("id")
    if err != nil {
        ctx.StatusCode(iris.StatusBadRequest)
        ctx.JSON(iris.Map{"error": "无效的ID参数"})
        return
    }
    
    // 获取所有路径参数
    allParams := ctx.Params()
    
    ctx.JSON(iris.Map{
        "id":         id,
        "name":       name,
        "user_id":    userID,
        "all_params": allParams,
    })
}

// 路由定义
app.Get("/users/{id:int}", pathParameters)
app.Get("/posts/{category}/{slug:string}", pathParameters)
```

### 2. 参数验证

```go
func validatePathParams(ctx iris.Context) {
    // 获取并验证ID参数
    id, err := ctx.Params().GetInt("id")
    if err != nil {
        ctx.StatusCode(iris.StatusBadRequest)
        ctx.JSON(iris.Map{
            "error": "ID必须是整数",
            "code":   "INVALID_ID",
        })
        return
    }
    
    // 验证ID范围
    if id <= 0 {
        ctx.StatusCode(iris.StatusBadRequest)
        ctx.JSON(iris.Map{
            "error": "ID必须大于0",
            "code":   "INVALID_ID_RANGE",
        })
        return
    }
    
    // 验证ID最大值
    if id > 1000000 {
        ctx.StatusCode(iris.StatusBadRequest)
        ctx.JSON(iris.Map{
            "error": "ID值过大",
            "code":   "ID_TOO_LARGE",
        })
        return
    }
    
    ctx.JSON(iris.Map{"id": id, "valid": true})
}
```

## 请求头处理

### 1. 获取请求头

```go
func requestHeaders(ctx iris.Context) {
    // 获取单个请求头
    userAgent := ctx.GetHeader("User-Agent")
    accept := ctx.GetHeader("Accept")
    authorization := ctx.GetHeader("Authorization")
    
    // 获取所有请求头
    headers := make(map[string]string)
    for name, values := range ctx.Request().Header {
        if len(values) > 0 {
            headers[name] = values[0]
        }
    }
    
    // 获取多值请求头
    acceptEncoding := ctx.GetHeader("Accept-Encoding")
    cookies := ctx.GetHeader("Cookie")
    
    ctx.JSON(iris.Map{
        "user_agent":      userAgent,
        "accept":          accept,
        "authorization":   authorization,
        "accept_encoding":  acceptEncoding,
        "cookies":         cookies,
        "all_headers":     headers,
    })
}
```

### 2. 特殊请求头处理

```go
func specialHeaders(ctx iris.Context) {
    // Content-Type 处理
    contentType := ctx.GetContentType()
    contentLength := ctx.GetContentLength()
    
    // Range 头处理（用于分块下载）
    rangeHeader := ctx.GetHeader("Range")
    
    // If-Modified-Since 头处理（缓存）
    ifModifiedSince := ctx.GetHeader("If-Modified-Since")
    
    // X-Requested-With 头（AJAX 请求检测）
    isAJAX := ctx.GetHeader("X-Requested-With") == "XMLHttpRequest"
    
    // X-Forwarded-For 头（代理检测）
    forwardedFor := ctx.GetHeader("X-Forwarded-For")
    
    // Referer 头
    referer := ctx.GetHeader("Referer")
    
    ctx.JSON(iris.Map{
        "content_type":      contentType,
        "content_length":    contentLength,
        "range":             rangeHeader,
        "if_modified_since": ifModifiedSince,
        "is_ajax":           isAJAX,
        "forwarded_for":     forwardedFor,
        "referer":           referer,
    })
}
```

## 请求体处理

### 1. JSON 数据处理

```go
func handleJSONData(ctx iris.Context) {
    // 定义数据结构
    var user struct {
        Name     string `json:"name"`
        Email    string `json:"email"`
        Age      int    `json:"age"`
        Active   bool   `json:"active"`
        Tags     []string `json:"tags"`
        Profile  struct {
            Bio    string `json:"bio"`
            Avatar string `json:"avatar"`
        } `json:"profile"`
    }
    
    // 读取 JSON 数据
    if err := ctx.ReadJSON(&user); err != nil {
        ctx.StatusCode(iris.StatusBadRequest)
        ctx.JSON(iris.Map{
            "error": "JSON 数据解析失败",
            "details": err.Error(),
        })
        return
    }
    
    // 返回解析后的数据
    ctx.JSON(iris.Map{
        "message": "JSON 数据解析成功",
        "data":    user,
    })
}
```

### 2. 表单数据处理

```go
func handleFormData(ctx iris.Context) {
    // 定义表单数据结构
    var formData struct {
        Username  string `form:"username"`
        Password  string `form:"password"`
        Email     string `form:"email"`
        Age       int    `form:"age"`
        Gender    string `form:"gender"`
        Interests []string `form:"interests"`
        Remember  bool   `form:"remember"`
    }
    
    // 读取表单数据
    if err := ctx.ReadForm(&formData); err != nil {
        ctx.StatusCode(iris.StatusBadRequest)
        ctx.JSON(iris.Map{
            "error": "表单数据解析失败",
            "details": err.Error(),
        })
        return
    }
    
    // 也可以单独获取表单字段
    username := ctx.FormValue("username")
    password := ctx.FormValue("password")
    
    // 获取多值表单字段
    interests := ctx.FormValues("interests")
    
    // 获取文件字段
    file, info, err := ctx.FormFile("avatar")
    if err == nil {
        defer file.Close()
        // 处理上传的文件
        ctx.JSON(iris.Map{
            "message": "表单数据解析成功",
            "form_data": formData,
            "username": username,
            "password": password,
            "interests": interests,
            "file_info": iris.Map{
                "filename": info.Filename,
                "size":     info.Size,
                "header":   info.Header,
            },
        })
    } else {
        ctx.JSON(iris.Map{
            "message": "表单数据解析成功",
            "form_data": formData,
            "username": username,
            "password": password,
            "interests": interests,
        })
    }
}
```

### 3. XML 数据处理

```go
func handleXMLData(ctx iris.Context) {
    // 定义 XML 数据结构
    var order struct {
        XMLName xml.Name `xml:"order"`
        ID      int      `xml:"id"`
        Customer struct {
            Name  string `xml:"name"`
            Email string `xml:"email"`
        } `xml:"customer"`
        Items []struct {
            ID    string `xml:"id"`
            Name  string `xml:"name"`
            Price float64 `xml:"price"`
            Qty   int    `xml:"qty"`
        } `xml:"items>item"`
    }
    
    // 读取 XML 数据
    if err := ctx.ReadXML(&order); err != nil {
        ctx.StatusCode(iris.StatusBadRequest)
        ctx.JSON(iris.Map{
            "error": "XML 数据解析失败",
            "details": err.Error(),
        })
        return
    }
    
    ctx.JSON(iris.Map{
        "message": "XML 数据解析成功",
        "data":    order,
    })
}
```

### 4. 原始数据处理

```go
func handleRawData(ctx iris.Context) {
    // 读取原始请求体
    body, err := ctx.GetBody()
    if err != nil {
        ctx.StatusCode(iris.StatusInternalServerError)
        ctx.JSON(iris.Map{"error": "读取请求体失败"})
        return
    }
    
    // 获取内容类型
    contentType := ctx.GetContentType()
    
    // 根据内容类型处理数据
    switch {
    case strings.Contains(contentType, "application/json"):
        var data interface{}
        json.Unmarshal(body, &data)
        ctx.JSON(iris.Map{
            "type": "json",
            "data": data,
        })
        
    case strings.Contains(contentType, "text/plain"):
        ctx.JSON(iris.Map{
            "type": "text",
            "data": string(body),
        })
        
    default:
        ctx.JSON(iris.Map{
            "type": "raw",
            "size": len(body),
            "data": string(body)[:min(200, len(body))], // 只显示前200个字符
        })
    }
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

## 文件上传处理

### 1. 单文件上传

```go
func handleSingleFileUpload(ctx iris.Context) {
    // 获取上传的文件
    file, info, err := ctx.FormFile("file")
    if err != nil {
        ctx.StatusCode(iris.StatusBadRequest)
        ctx.JSON(iris.Map{
            "error": "文件上传失败",
            "details": err.Error(),
        })
        return
    }
    defer file.Close()
    
    // 验证文件大小
    maxSize := int64(10 << 20) // 10MB
    if info.Size > maxSize {
        ctx.StatusCode(iris.StatusBadRequest)
        ctx.JSON(iris.Map{
            "error": "文件大小超过限制",
            "max_size": maxSize,
            "file_size": info.Size,
        })
        return
    }
    
    // 验证文件类型
    allowedTypes := []string{
        "image/jpeg",
        "image/png",
        "image/gif",
        "application/pdf",
    }
    
    contentType := info.Header.Get("Content-Type")
    if !contains(allowedTypes, contentType) {
        ctx.StatusCode(iris.StatusBadRequest)
        ctx.JSON(iris.Map{
            "error": "不支持的文件类型",
            "content_type": contentType,
            "allowed_types": allowedTypes,
        })
        return
    }
    
    // 生成唯一文件名
    filename := generateUniqueFilename(info.Filename)
    savePath := filepath.Join("uploads", filename)
    
    // 保存文件
    if err := saveUploadedFile(file, savePath); err != nil {
        ctx.StatusCode(iris.StatusInternalServerError)
        ctx.JSON(iris.Map{
            "error": "文件保存失败",
            "details": err.Error(),
        })
        return
    }
    
    ctx.JSON(iris.Map{
        "message": "文件上传成功",
        "filename": filename,
        "original_name": info.Filename,
        "size": info.Size,
        "content_type": contentType,
        "url": "/uploads/" + filename,
    })
}
```

### 2. 多文件上传

```go
func handleMultipleFileUpload(ctx iris.Context) {
    // 获取所有上传的文件
    files := ctx.UploadFiles()
    if len(files) == 0 {
        ctx.StatusCode(iris.StatusBadRequest)
        ctx.JSON(iris.Map{"error": "没有上传文件"})
        return
    }
    
    var uploadedFiles []iris.Map
    var errors []iris.Map
    
    for _, file := range files {
        // 验证文件
        if err := validateUploadedFile(file); err != nil {
            errors = append(errors, iris.Map{
                "filename": file.Filename,
                "error": err.Error(),
            })
            continue
        }
        
        // 保存文件
        filename := generateUniqueFilename(file.Filename)
        savePath := filepath.Join("uploads", filename)
        
        if err := saveUploadedFile(file.File, savePath); err != nil {
            errors = append(errors, iris.Map{
                "filename": file.Filename,
                "error": "文件保存失败: " + err.Error(),
            })
            continue
        }
        
        uploadedFiles = append(uploadedFiles, iris.Map{
            "filename": filename,
            "original_name": file.Filename,
            "size": file.Size,
            "url": "/uploads/" + filename,
        })
    }
    
    ctx.JSON(iris.Map{
        "message": "文件上传处理完成",
        "uploaded_files": uploadedFiles,
        "errors": errors,
        "total_uploaded": len(uploadedFiles),
        "total_errors": len(errors),
    })
}
```

## 请求数据验证

### 1. 结构体验证

```go
type CreateUserRequest struct {
    Username string `json:"username" validate:"required,min=3,max=20"`
    Email    string `json:"email" validate:"required,email"`
    Password string `json:"password" validate:"required,min=6"`
    Age      int    `json:"age" validate:"gte=18,lte=120"`
    Phone    string `json:"phone" validate:"phone"`
    Address  string `json:"address" validate:"max=200"`
}

func createUser(ctx iris.Context) {
    var req CreateUserRequest
    
    // 读取请求数据
    if err := ctx.ReadJSON(&req); err != nil {
        ctx.StatusCode(iris.StatusBadRequest)
        ctx.JSON(iris.Map{
            "error": "请求数据格式错误",
            "details": err.Error(),
        })
        return
    }
    
    // 验证数据
    if err := utils.ValidateStruct(&req); err != nil {
        ctx.StatusCode(iris.StatusBadRequest)
        ctx.JSON(iris.Map{
            "error": "数据验证失败",
            "details": err.Error(),
        })
        return
    }
    
    // 处理业务逻辑...
    ctx.JSON(iris.Map{
        "message": "用户创建成功",
        "data": req,
    })
}
```

### 2. 自定义验证

```go
func customValidation(ctx iris.Context) {
    var data struct {
        Password string `json:"password"`
        ConfirmPassword string `json:"confirm_password"`
        Email string `json:"email"`
    }
    
    if err := ctx.ReadJSON(&data); err != nil {
        ctx.StatusCode(iris.StatusBadRequest)
        ctx.JSON(iris.Map{"error": "数据格式错误"})
        return
    }
    
    var errors []string
    
    // 密码匹配验证
    if data.Password != data.ConfirmPassword {
        errors = append(errors, "密码和确认密码不匹配")
    }
    
    // 密码强度验证
    if !isStrongPassword(data.Password) {
        errors = append(errors, "密码强度不够")
    }
    
    // 邮箱域名验证
    if !isValidEmailDomain(data.Email) {
        errors = append(errors, "邮箱域名不被支持")
    }
    
    if len(errors) > 0 {
        ctx.StatusCode(iris.StatusBadRequest)
        ctx.JSON(iris.Map{
            "error": "验证失败",
            "errors": errors,
        })
        return
    }
    
    ctx.JSON(iris.Map{"message": "验证通过"})
}

func isStrongPassword(password string) bool {
    hasUpper := false
    hasLower := false
    hasNumber := false
    hasSpecial := false
    
    for _, char := range password {
        switch {
        case char >= 'A' && char <= 'Z':
            hasUpper = true
        case char >= 'a' && char <= 'z':
            hasLower = true
        case char >= '0' && char <= '9':
            hasNumber = true
        case strings.ContainsRune("!@#$%^&*()_+-=[]{}|;:,.<>?", char):
            hasSpecial = true
        }
    }
    
    return hasUpper && hasLower && hasNumber && hasSpecial && len(password) >= 8
}

func isValidEmailDomain(email string) bool {
    domain := strings.Split(email, "@")[1]
    allowedDomains := []string{"gmail.com", "qq.com", "163.com", "outlook.com"}
    
    for _, allowed := range allowedDomains {
        if domain == allowed {
            return true
        }
    }
    return false
}
```

## 请求上下文

### 1. 上下文数据存储

```go
func contextData(ctx iris.Context) {
    // 设置上下文数据
    ctx.Values().Set("user_id", 123)
    ctx.Values().Set("username", "john_doe")
    ctx.Values().Set("role", "admin")
    
    // 获取上下文数据
    userID := ctx.Values().GetIntDefault("user_id", 0)
    username := ctx.Values().GetStringDefault("username", "")
    role := ctx.Values().GetStringDefault("role", "")
    
    // 类型化获取
    var user struct {
        ID   int    `json:"id"`
        Name string `json:"name"`
    }
    
    if err := ctx.Values().GetUnmarshaler("user", &user); err == nil {
        // 使用解析后的用户数据
    }
    
    // 检查键是否存在
    if ctx.Values().IsAvailable("session_id") {
        sessionID := ctx.Values().GetString("session_id")
        // 使用 session_id
    }
    
    ctx.JSON(iris.Map{
        "user_id":  userID,
        "username": username,
        "role":     role,
    })
}
```

### 2. 请求取消和超时

```go
func handleRequestTimeout(ctx iris.Context) {
    // 获取请求上下文
    reqCtx := ctx.Request().Context()
    
    // 模拟长时间运行的任务
    result := make(chan string)
    go func() {
        // 模拟耗时操作
        time.Sleep(5 * time.Second)
        result <- "操作完成"
    }()
    
    select {
    case res := <-result:
        ctx.JSON(iris.Map{"result": res})
    case <-reqCtx.Done():
        // 请求被取消
        ctx.StatusCode(iris.StatusRequestTimeout)
        ctx.JSON(iris.Map{"error": "请求超时或被取消"})
    case <-time.After(3 * time.Second):
        // 超时处理
        ctx.StatusCode(iris.StatusRequestTimeout)
        ctx.JSON(iris.Map{"error": "操作超时"})
    }
}
```

## 最佳实践

### 1. 错误处理

```go
func robustRequestHandler(ctx iris.Context) {
    // 统一的错误处理
    defer func() {
        if err := recover(); err != nil {
            log.Printf("Request panic: %v", err)
            ctx.StatusCode(iris.StatusInternalServerError)
            ctx.JSON(iris.Map{
                "error": "服务器内部错误",
                "code": "INTERNAL_ERROR",
            })
        }
    }()
    
    // 参数验证
    if err := validateRequest(ctx); err != nil {
        ctx.StatusCode(iris.StatusBadRequest)
        ctx.JSON(iris.Map{
            "error": err.Error(),
            "code": "VALIDATION_ERROR",
        })
        return
    }
    
    // 业务逻辑处理
    result, err := processRequest(ctx)
    if err != nil {
        handleBusinessError(ctx, err)
        return
    }
    
    // 返回成功响应
    ctx.JSON(iris.Map{
        "success": true,
        "data": result,
    })
}
```

### 2. 性能优化

```go
func optimizedHandler(ctx iris.Context) {
    // 限制请求体大小
    ctx.Request().Body = http.MaxBytesReader(ctx.ResponseWriter(), 
        ctx.Request().Body, 1<<20) // 1MB
    
    // 使用连接池
    buffer := bufferPool.Get().([]byte)
    defer bufferPool.Put(buffer)
    
    // 异步处理
    go func() {
        // 非关键路径的异步处理
        asyncProcess(ctx)
    }()
    
    // 快速响应
    ctx.JSON(iris.Map{"message": "请求已接收"})
}
```

## 下一步

现在您已经掌握了请求处理的各种技巧，建议继续学习：

1. [响应处理](./05-响应处理.md) - 掌握各种响应格式和技巧
2. [静态文件](./06-静态文件.md) - 学习静态文件服务
3. [模板引擎](./07-模板引擎.md) - 掌握模板渲染

## 相关资源

- [Iris 请求处理文档](https://iris-go.com/context)
- [HTTP 请求规范](https://tools.ietf.org/html/rfc7231)
- [Go JSON 处理](https://golang.org/pkg/encoding/json/)