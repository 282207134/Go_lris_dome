# 09 - 身份验证

## 身份验证概述

身份验证是 Web 应用的核心安全机制，用于确认用户身份。本项目实现了基于 JWT（JSON Web Token）的身份验证系统，支持用户注册、登录、令牌刷新等功能。

## JWT 认证系统

### 1. JWT 工具类

```go
package utils

import (
    "fmt"
    "time"
    
    "iris-cn-sample-project/config"
    
    "github.com/golang-jwt/jwt/v5"
)

// JWTClaims JWT 声明结构体
type JWTClaims struct {
    UserID   uint   `json:"user_id"`
    Username string `json:"username"`
    Role     string `json:"role"`
    jwt.RegisteredClaims
}

// GenerateJWT 生成 JWT 令牌
func GenerateJWT(userID uint, username, role string) (string, time.Time, error) {
    cfg := config.GetConfig()
    
    // 设置过期时间
    expirationTime := time.Now().Add(time.Duration(cfg.JWT.ExpirationTime) * time.Second)
    
    // 创建 JWT 声明
    claims := &JWTClaims{
        UserID:   userID,
        Username: username,
        Role:     role,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(expirationTime),
            IssuedAt:  jwt.NewNumericDate(time.Now()),
            NotBefore: jwt.NewNumericDate(time.Now()),
            Issuer:    cfg.JWT.Issuer,
            Subject:   fmt.Sprintf("user:%d", userID),
            ID:        fmt.Sprintf("%d_%d", userID, time.Now().Unix()),
        },
    }

    // 创建令牌
    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    
    // 签名令牌
    tokenString, err := token.SignedString([]byte(cfg.JWT.Secret))
    if err != nil {
        return "", time.Time{}, fmt.Errorf("生成JWT令牌失败: %v", err)
    }

    return tokenString, expirationTime, nil
}

// ValidateJWT 验证 JWT 令牌
func ValidateJWT(tokenString string) (*JWTClaims, error) {
    cfg := config.GetConfig()
    
    // 解析令牌
    token, err := jwt.ParseWithClaims(tokenString, &JWTClaims{}, func(token *jwt.Token) (interface{}, error) {
        // 验证签名方法
        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
            return nil, fmt.Errorf("意外的签名方法: %v", token.Header["alg"])
        }
        return []byte(cfg.JWT.Secret), nil
    })

    if err != nil {
        return nil, fmt.Errorf("解析JWT令牌失败: %v", err)
    }

    // 验证令牌并提取声明
    if claims, ok := token.Claims.(*JWTClaims); ok && token.Valid {
        // 检查令牌是否过期
        if time.Now().After(claims.ExpiresAt.Time) {
            return nil, fmt.Errorf("令牌已过期")
        }
        
        // 检查令牌是否在生效时间之前
        if time.Now().Before(claims.NotBefore.Time) {
            return nil, fmt.Errorf("令牌尚未生效")
        }
        
        return claims, nil
    }

    return nil, fmt.Errorf("无效的JWT令牌")
}

// ParseJWTWithoutValidation 解析JWT令牌但不验证签名和过期时间
func ParseJWTWithoutValidation(tokenString string) (*JWTClaims, error) {
    // 解析令牌但不验证签名
    token, _, err := jwt.NewParser().ParseUnverified(tokenString, &JWTClaims{})
    if err != nil {
        return nil, fmt.Errorf("解析JWT令牌失败: %v", err)
    }

    if claims, ok := token.Claims.(*JWTClaims); ok {
        return claims, nil
    }

    return nil, fmt.Errorf("无法解析JWT声明")
}

// RefreshJWT 刷新JWT令牌
func RefreshJWT(tokenString string) (string, time.Time, error) {
    // 首先解析原始令牌（不验证过期时间）
    claims, err := ParseJWTWithoutValidation(tokenString)
    if err != nil {
        return "", time.Time{}, fmt.Errorf("解析原始令牌失败: %v", err)
    }

    // 生成新的令牌
    newToken, expirationTime, err := GenerateJWT(claims.UserID, claims.Username, claims.Role)
    if err != nil {
        return "", time.Time{}, fmt.Errorf("生成新令牌失败: %v", err)
    }

    return newToken, expirationTime, nil
}

// GetJWTFromHeader 从请求头中提取JWT令牌
func GetJWTFromHeader(authHeader string) (string, error) {
    const bearerPrefix = "Bearer "
    
    if authHeader == "" {
        return "", fmt.Errorf("缺少Authorization头")
    }
    
    if len(authHeader) <= len(bearerPrefix) {
        return "", fmt.Errorf("Authorization头格式错误")
    }
    
    if authHeader[:len(bearerPrefix)] != bearerPrefix {
        return "", fmt.Errorf("Authorization头必须以Bearer开头")
    }
    
    return authHeader[len(bearerPrefix):], nil
}
```

### 2. 认证中间件

```go
package middleware

import (
    "strings"
    
    "iris-cn-sample-project/utils"
    
    "github.com/kataras/iris/v12"
)

// JWTAuthentication JWT 认证中间件
func JWTAuthentication() iris.Handler {
    return func(ctx iris.Context) {
        // 从请求头获取 Authorization
        authHeader := ctx.GetHeader("Authorization")
        if authHeader == "" {
            ctx.JSON(iris.Map{
                "code":    401,
                "message": "缺少认证令牌",
            })
            ctx.StatusCode(iris.StatusUnauthorized)
            return
        }

        // 检查 Bearer 前缀
        const bearerPrefix = "Bearer "
        if !strings.HasPrefix(authHeader, bearerPrefix) {
            ctx.JSON(iris.Map{
                "code":    401,
                "message": "认证令牌格式错误",
            })
            ctx.StatusCode(iris.StatusUnauthorized)
            return
        }

        // 提取令牌
        tokenString := authHeader[len(bearerPrefix):]
        
        // 验证令牌
        claims, err := utils.ValidateJWT(tokenString)
        if err != nil {
            ctx.JSON(iris.Map{
                "code":    401,
                "message": "无效的认证令牌: " + err.Error(),
            })
            ctx.StatusCode(iris.StatusUnauthorized)
            return
        }

        // 将用户信息存储到上下文中
        ctx.Values().Set("user_id", claims.UserID)
        ctx.Values().Set("username", claims.Username)
        ctx.Values().Set("role", claims.Role)

        // 继续处理请求
        ctx.Next()
    }
}

// RequireRole 角色验证中间件
func RequireRole(roles ...string) iris.Handler {
    return func(ctx iris.Context) {
        // 获取用户角色
        userRole, ok := ctx.Values().GetString("role")
        if !ok {
            ctx.JSON(iris.Map{
                "code":    403,
                "message": "无法获取用户角色信息",
            })
            ctx.StatusCode(iris.StatusForbidden)
            return
        }

        // 检查用户角色是否在允许的角色列表中
        hasPermission := false
        for _, role := range roles {
            if userRole == role {
                hasPermission = true
                break
            }
        }

        if !hasPermission {
            ctx.JSON(iris.Map{
                "code":    403,
                "message": "权限不足",
            })
            ctx.StatusCode(iris.StatusForbidden)
            return
        }

        ctx.Next()
    }
}

// RequireAdmin 管理员权限中间件
func RequireAdmin() iris.Handler {
    return RequireRole("admin")
}

// OptionalAuthentication 可选认证中间件
func OptionalAuthentication() iris.Handler {
    return func(ctx iris.Context) {
        // 从请求头获取 Authorization
        authHeader := ctx.GetHeader("Authorization")
        if authHeader == "" {
            // 没有认证头，继续处理请求
            ctx.Next()
            return
        }

        // 检查 Bearer 前缀
        const bearerPrefix = "Bearer "
        if !strings.HasPrefix(authHeader, bearerPrefix) {
            // 格式错误，继续处理请求
            ctx.Next()
            return
        }

        // 提取令牌
        tokenString := authHeader[len(bearerPrefix):]
        
        // 验证令牌
        claims, err := utils.ValidateJWT(tokenString)
        if err != nil {
            // 令牌无效，继续处理请求
            ctx.Next()
            return
        }

        // 将用户信息存储到上下文中
        ctx.Values().Set("user_id", claims.UserID)
        ctx.Values().Set("username", claims.Username)
        ctx.Values().Set("role", claims.Role)

        // 继续处理请求
        ctx.Next()
    }
}
```

## 用户认证服务

### 1. 认证服务

```go
package services

import (
    "errors"
    "fmt"
    "time"
    
    "iris-cn-sample-project/database"
    "iris-cn-sample-project/models"
    "iris-cn-sample-project/utils"
    
    "golang.org/x/crypto/bcrypt"
    "gorm.io/gorm"
)

// AuthService 认证服务
type AuthService struct {
    db *gorm.DB
}

// NewAuthService 创建认证服务实例
func NewAuthService() *AuthService {
    return &AuthService{
        db: database.GetDB(),
    }
}

// Login 用户登录
func (s *AuthService) Login(username, password string) (*models.User, error) {
    // 查找用户（支持用户名或邮箱登录）
    var user models.User
    err := s.db.Where("username = ? OR email = ?", username, username).First(&user).Error
    if err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, errors.New("用户不存在")
        }
        return nil, fmt.Errorf("查询用户失败: %v", err)
    }

    // 检查用户状态
    if !user.IsActive() {
        return nil, errors.New("用户账户已被禁用")
    }

    // 验证密码
    if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password)); err != nil {
        return nil, errors.New("密码错误")
    }

    return &user, nil
}

// Register 用户注册
func (s *AuthService) Register(req *models.RegisterRequest) (*models.User, error) {
    // 检查用户名是否已存在
    var existingUser models.User
    if err := s.db.Where("username = ?", req.Username).First(&existingUser).Error; err == nil {
        return nil, errors.New("用户名已存在")
    }

    // 检查邮箱是否已存在
    if err := s.db.Where("email = ?", req.Email).First(&existingUser).Error; err == nil {
        return nil, errors.New("邮箱已存在")
    }

    // 加密密码
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
    if err != nil {
        return nil, fmt.Errorf("密码加密失败: %v", err)
    }

    // 创建用户
    user := &models.User{
        Username:  req.Username,
        Email:     req.Email,
        Password:  string(hashedPassword),
        FirstName: req.FirstName,
        LastName:  req.LastName,
        Role:      "user",
        Status:    "active",
    }

    if err := s.db.Create(user).Error; err != nil {
        return nil, fmt.Errorf("创建用户失败: %v", err)
    }

    return user, nil
}

// ChangePassword 修改密码
func (s *AuthService) ChangePassword(userID uint, oldPassword, newPassword string) error {
    // 查找用户
    var user models.User
    if err := s.db.First(&user, userID).Error; err != nil {
        return errors.New("用户不存在")
    }

    // 验证旧密码
    if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(oldPassword)); err != nil {
        return errors.New("旧密码错误")
    }

    // 加密新密码
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(newPassword), bcrypt.DefaultCost)
    if err != nil {
        return fmt.Errorf("密码加密失败: %v", err)
    }

    // 更新密码
    if err := s.db.Model(&user).Update("password", string(hashedPassword)).Error; err != nil {
        return fmt.Errorf("更新密码失败: %v", err)
    }

    return nil
}

// ResetPassword 重置密码
func (s *AuthService) ResetPassword(email string, newPassword string) error {
    // 查找用户
    var user models.User
    if err := s.db.Where("email = ?", email).First(&user).Error; err != nil {
        return errors.New("用户不存在")
    }

    // 加密新密码
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(newPassword), bcrypt.DefaultCost)
    if err != nil {
        return fmt.Errorf("密码加密失败: %v", err)
    }

    // 更新密码
    if err := s.db.Model(&user).Update("password", string(hashedPassword)).Error; err != nil {
        return fmt.Errorf("更新密码失败: %v", err)
    }

    return nil
}

// ValidateCredentials 验证用户凭据
func (s *AuthService) ValidateCredentials(username, password string) (*models.User, error) {
    return s.Login(username, password)
}

// RefreshToken 刷新令牌
func (s *AuthService) RefreshToken(refreshTokenString string) (string, string, time.Time, error) {
    // 解析刷新令牌（不验证过期时间）
    refreshToken, err := jwt.ParseWithClaims(refreshTokenString, &utils.JWTClaims{}, func(token *jwt.Token) (interface{}, error) {
        // 验证签名方法
        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
            return nil, fmt.Errorf("意外的签名方法: %v", token.Header["alg"])
        }
        return []byte(config.GetConfig().JWT.Secret), nil
    })

    if err != nil {
        return "", "", time.Time{}, fmt.Errorf("解析刷新令牌失败: %v", err)
    }

    // 检查令牌是否有效
    if claims, ok := refreshToken.Claims.(*utils.JWTClaims); ok && refreshToken.Valid {
        // 验证用户是否仍然存在且有效
        user, err := s.GetUserByID(claims.UserID)
        if err != nil {
            return "", "", time.Time{}, fmt.Errorf("用户不存在或已被禁用: %v", err)
        }

        // 生成新的访问令牌
        newToken, expiresAt, err := utils.GenerateJWT(user.ID, user.Username, user.Role)
        if err != nil {
            return "", "", time.Time{}, fmt.Errorf("生成新令牌失败: %v", err)
        }

        return newToken, "", expiresAt, nil
    }

    return "", "", time.Time{}, errors.New("无效的刷新令牌")
}

// GetUserByID 根据ID获取用户
func (s *AuthService) GetUserByID(userID uint) (*models.User, error) {
    var user models.User
    if err := s.db.Where("id = ? AND status = ?", userID, "active").First(&user).Error; err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, errors.New("用户不存在")
        }
        return nil, fmt.Errorf("查询用户失败: %v", err)
    }
    return &user, nil
}

// UpdateLastLogin 更新最后登录时间
func (s *AuthService) UpdateLastLogin(userID uint) error {
    now := time.Now()
    return s.db.Model(&models.User{}).Where("id = ?", userID).Update("last_login", &now).Error
}
```

### 2. 令牌管理

```go
package services

import (
    "crypto/rand"
    "encoding/hex"
    "fmt"
    "time"
    
    "iris-cn-sample-project/config"
    "iris-cn-sample-project/models"
    "iris-cn-sample-project/utils"
    
    "github.com/golang-jwt/jwt/v5"
)

// TokenService 令牌服务
type TokenService struct {
    authService *AuthService
}

// NewTokenService 创建令牌服务实例
func NewTokenService() *TokenService {
    return &TokenService{
        authService: NewAuthService(),
    }
}

// CreateTokenPair 创建令牌对（访问令牌 + 刷新令牌）
func (s *TokenService) CreateTokenPair(user *models.User) (*models.TokenPair, error) {
    // 生成访问令牌
    accessToken, expiresAt, err := utils.GenerateJWT(user.ID, user.Username, user.Role)
    if err != nil {
        return nil, fmt.Errorf("生成访问令牌失败: %v", err)
    }

    // 生成刷新令牌（有效期更长）
    refreshTokenExpiry := time.Now().Add(7 * 24 * time.Hour) // 7天
    refreshClaims := &utils.JWTClaims{
        UserID:   user.ID,
        Username: user.Username,
        Role:     user.Role,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(refreshTokenExpiry),
            IssuedAt:  jwt.NewNumericDate(time.Now()),
            NotBefore: jwt.NewNumericDate(time.Now()),
            Issuer:    config.GetConfig().JWT.Issuer,
            Subject:   fmt.Sprintf("user:%d", user.ID),
            ID:        s.generateTokenID(),
        },
    }

    refreshTokenObj := jwt.NewWithClaims(jwt.SigningMethodHS256, refreshClaims)
    refreshTokenString, err := refreshTokenObj.SignedString([]byte(config.GetConfig().JWT.Secret))
    if err != nil {
        return nil, fmt.Errorf("生成刷新令牌失败: %v", err)
    }

    // 更新用户最后登录时间
    s.authService.UpdateLastLogin(user.ID)

    return &models.TokenPair{
        AccessToken:  accessToken,
        RefreshToken: refreshTokenString,
        TokenType:    "Bearer",
        ExpiresIn:    int(time.Until(expiresAt).Seconds()),
        ExpiresAt:    expiresAt,
    }, nil
}

// RefreshAccessToken 使用刷新令牌获取新的访问令牌
func (s *TokenService) RefreshAccessToken(refreshTokenString string) (*models.TokenPair, error) {
    // 解析刷新令牌（不验证过期时间）
    refreshToken, err := jwt.ParseWithClaims(refreshTokenString, &utils.JWTClaims{}, func(token *jwt.Token) (interface{}, error) {
        // 验证签名方法
        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
            return nil, fmt.Errorf("意外的签名方法: %v", token.Header["alg"])
        }
        return []byte(config.GetConfig().JWT.Secret), nil
    })

    if err != nil {
        return nil, fmt.Errorf("解析刷新令牌失败: %v", err)
    }

    // 检查令牌是否有效
    if claims, ok := refreshToken.Claims.(*utils.JWTClaims); ok && refreshToken.Valid {
        // 验证用户是否仍然存在且有效
        user, err := s.authService.GetUserByID(claims.UserID)
        if err != nil {
            return nil, fmt.Errorf("用户不存在或已被禁用: %v", err)
        }

        // 生成新的访问令牌
        newToken, expiresAt, err := utils.GenerateJWT(user.ID, user.Username, user.Role)
        if err != nil {
            return nil, fmt.Errorf("生成新令牌失败: %v", err)
        }

        return &models.TokenPair{
            AccessToken: newToken,
            TokenType:   "Bearer",
            ExpiresIn:   int(time.Until(expiresAt).Seconds()),
            ExpiresAt:   expiresAt,
        }, nil
    }

    return nil, errors.New("无效的刷新令牌")
}

// ValidateToken 验证令牌
func (s *TokenService) ValidateToken(tokenString string) (*models.User, error) {
    // 验证 JWT 令牌
    claims, err := utils.ValidateJWT(tokenString)
    if err != nil {
        return nil, fmt.Errorf("令牌验证失败: %v", err)
    }

    // 根据令牌中的用户ID获取用户信息
    user, err := s.authService.GetUserByID(claims.UserID)
    if err != nil {
        return nil, fmt.Errorf("获取用户信息失败: %v", err)
    }

    return user, nil
}

// InvalidateToken 使令牌失效（在实际应用中，可以将令牌加入黑名单）
func (s *TokenService) InvalidateToken(tokenString string) error {
    // 这里简化处理，实际应用中可以实现令牌黑名单机制
    // 例如将令牌的 JTI（JWT ID）存储在 Redis 或数据库中
    // 并在验证时检查令牌是否在黑名单中
    
    // 模拟将令牌加入黑名单
    _ = tokenString
    
    return nil
}

// generateTokenID 生成令牌ID
func (s *TokenService) generateTokenID() string {
    bytes := make([]byte, 16)
    rand.Read(bytes)
    return hex.EncodeToString(bytes)
}
```

## 认证控制器

### 1. 认证接口

```go
package controllers

import (
    "time"
    
    "iris-cn-sample-project/models"
    "iris-cn-sample-project/services"
    "iris-cn-sample-project/utils"
    
    "github.com/kataras/iris/v12"
)

// Login 用户登录接口
func Login(ctx iris.Context) {
    // 解析登录请求数据
    var loginReq models.LoginRequest
    if err := ctx.ReadJSON(&loginReq); err != nil {
        ctx.JSON(models.NewErrorResponse(400, "请求数据格式错误: "+err.Error(), nil))
        return
    }

    // 验证输入数据
    if err := utils.ValidateStruct(&loginReq); err != nil {
        ctx.JSON(models.NewErrorResponse(400, "输入数据验证失败", err))
        return
    }

    // 调用认证服务进行登录验证
    authService := services.NewAuthService()
    user, err := authService.Login(loginReq.Username, loginReq.Password)
    if err != nil {
        ctx.JSON(models.NewErrorResponse(401, "用户名或密码错误", nil))
        return
    }

    // 生成令牌对
    tokenService := services.NewTokenService()
    tokenPair, err := tokenService.CreateTokenPair(user)
    if err != nil {
        ctx.JSON(models.NewErrorResponse(500, "生成令牌失败: "+err.Error(), nil))
        return
    }

    // 构建登录响应
    loginResp := &models.LoginResponse{
        Token:     tokenPair.AccessToken,
        ExpiresAt: tokenPair.ExpiresAt,
        User: &models.UserInfo{
            ID:        user.ID,
            Username:  user.Username,
            Email:     user.Email,
            FirstName: user.FirstName,
            LastName:  user.LastName,
            Avatar:    user.Avatar,
            Role:      user.Role,
            Status:    user.Status,
            CreatedAt: user.CreatedAt,
            UpdatedAt: user.UpdatedAt,
        },
    }

    ctx.JSON(models.NewResponse(200, "登录成功", loginResp))
}

// Register 用户注册接口
func Register(ctx iris.Context) {
    // 解析注册请求数据
    var registerReq models.RegisterRequest
    if err := ctx.ReadJSON(&registerReq); err != nil {
        ctx.JSON(models.NewErrorResponse(400, "请求数据格式错误: "+err.Error(), nil))
        return
    }

    // 验证输入数据
    if err := utils.ValidateStruct(&registerReq); err != nil {
        ctx.JSON(models.NewErrorResponse(400, "输入数据验证失败", err))
        return
    }

    // 调用认证服务创建用户
    authService := services.NewAuthService()
    user, err := authService.Register(&registerReq)
    if err != nil {
        ctx.JSON(models.NewErrorResponse(400, "用户注册失败: "+err.Error(), nil))
        return
    }

    // 返回注册成功响应（不包含敏感信息）
    userInfo := &models.UserInfo{
        ID:        user.ID,
        Username:  user.Username,
        Email:     user.Email,
        FirstName: user.FirstName,
        LastName:  user.LastName,
        Avatar:    user.Avatar,
        Role:      user.Role,
        Status:    user.Status,
        CreatedAt: user.CreatedAt,
        UpdatedAt: user.UpdatedAt,
    }

    ctx.JSON(models.NewResponse(201, "用户注册成功", userInfo))
}

// RefreshToken 刷新令牌接口
func RefreshToken(ctx iris.Context) {
    // 从请求头获取当前令牌
    authHeader := ctx.GetHeader("Authorization")
    if authHeader == "" {
        ctx.JSON(models.NewErrorResponse(401, "缺少认证令牌", nil))
        return
    }

    // 提取令牌
    tokenString, err := utils.GetJWTFromHeader(authHeader)
    if err != nil {
        ctx.JSON(models.NewErrorResponse(401, "认证令牌格式错误", nil))
        return
    }

    // 使用令牌服务刷新令牌
    tokenService := services.NewTokenService()
    tokenPair, err := tokenService.RefreshAccessToken(tokenString)
    if err != nil {
        ctx.JSON(models.NewErrorResponse(401, "令牌刷新失败: "+err.Error(), nil))
        return
    }

    ctx.JSON(models.NewResponse(200, "令牌刷新成功", tokenPair))
}

// Logout 用户登出接口
func Logout(ctx iris.Context) {
    // 在实际应用中，这里可以将令牌加入黑名单
    // 由于 JWT 是无状态的，真正的登出需要在客户端删除令牌
    
    ctx.JSON(models.NewResponse(200, "登出成功", map[string]interface{}{
        "message": "请在客户端删除存储的令牌",
    }))
}

// ChangePassword 修改密码接口
func ChangePassword(ctx iris.Context) {
    // 获取当前用户ID
    userID := ctx.Values().GetUintDefault("user_id", 0)
    if userID == 0 {
        ctx.JSON(models.NewErrorResponse(401, "无效的用户信息", nil))
        return
    }

    // 解析修改密码请求数据
    var changePwdReq models.ChangePasswordRequest
    if err := ctx.ReadJSON(&changePwdReq); err != nil {
        ctx.JSON(models.NewErrorResponse(400, "请求数据格式错误: "+err.Error(), nil))
        return
    }

    // 验证输入数据
    if err := utils.ValidateStruct(&changePwdReq); err != nil {
        ctx.JSON(models.NewErrorResponse(400, "输入数据验证失败", err))
        return
    }

    // 调用认证服务修改密码
    authService := services.NewAuthService()
    if err := authService.ChangePassword(userID, changePwdReq.OldPassword, changePwdReq.NewPassword); err != nil {
        ctx.JSON(models.NewErrorResponse(400, "密码修改失败: "+err.Error(), nil))
        return
    }

    ctx.JSON(models.NewResponse(200, "密码修改成功", nil))
}

// GetProfile 获取当前认证用户信息
func GetProfile(ctx iris.Context) {
    // 从中间件获取用户信息
    userID := ctx.Values().GetUintDefault("user_id", 0)
    username := ctx.Values().GetStringDefault("username", "")
    role := ctx.Values().GetStringDefault("role", "")

    // 获取完整的用户信息
    authService := services.NewAuthService()
    user, err := authService.GetUserByID(userID)
    if err != nil {
        ctx.JSON(models.NewErrorResponse(404, "用户信息不存在", nil))
        return
    }

    // 返回用户信息
    userInfo := &models.UserInfo{
        ID:        user.ID,
        Username:  user.Username,
        Email:     user.Email,
        FirstName: user.FirstName,
        LastName:  user.LastName,
        Avatar:    user.Avatar,
        Role:      user.Role,
        Status:    user.Status,
        CreatedAt: user.CreatedAt,
        UpdatedAt: user.UpdatedAt,
    }

    ctx.JSON(models.NewResponse(200, "获取认证信息成功", map[string]interface{}{
        "user": userInfo,
        "token_info": map[string]interface{}{
            "user_id":  userID,
            "username": username,
            "role":     role,
            "issued_at": time.Now().Format("2006-01-02 15:04:05"),
        },
    }))
}

// ValidateToken 验证令牌接口
func ValidateToken(ctx iris.Context) {
    // 从请求头获取令牌
    authHeader := ctx.GetHeader("Authorization")
    if authHeader == "" {
        ctx.JSON(models.NewErrorResponse(401, "缺少认证令牌", nil))
        return
    }

    // 提取令牌
    tokenString, err := utils.GetJWTFromHeader(authHeader)
    if err != nil {
        ctx.JSON(models.NewErrorResponse(401, "认证令牌格式错误", nil))
        return
    }

    // 验证令牌
    tokenService := services.NewTokenService()
    user, err := tokenService.ValidateToken(tokenString)
    if err != nil {
        ctx.JSON(models.NewErrorResponse(401, "令牌验证失败: "+err.Error(), nil))
        return
    }

    // 检查用户是否仍然有效
    if !user.IsActive() {
        ctx.JSON(models.NewErrorResponse(401, "用户账户已被禁用", nil))
        return
    }

    // 解析令牌信息
    claims, _ := utils.ParseJWTWithoutValidation(tokenString)

    ctx.JSON(models.NewResponse(200, "令牌验证成功", map[string]interface{}{
        "valid":      true,
        "user_id":    claims.UserID,
        "username":   claims.Username,
        "role":       claims.Role,
        "expires_at": claims.ExpiresAt,
    }))
}
```

## 权限控制

### 1. 基于角色的访问控制（RBAC）

```go
package services

import (
    "fmt"
    
    "iris-cn-sample-project/database"
    "iris-cn-sample-project/models"
    
    "gorm.io/gorm"
)

// PermissionService 权限服务
type PermissionService struct {
    db *gorm.DB
}

// NewPermissionService 创建权限服务实例
func NewPermissionService() *PermissionService {
    return &PermissionService{
        db: database.GetDB(),
    }
}

// CheckPermission 检查用户权限
func (s *PermissionService) CheckPermission(userID uint, resource, action string) bool {
    // 获取用户角色
    var user models.User
    if err := s.db.First(&user, userID).Error; err != nil {
        return false
    }

    // 检查角色权限
    return s.checkRolePermission(user.Role, resource, action)
}

// checkRolePermission 检查角色权限
func (s *PermissionService) checkRolePermission(role, resource, action string) bool {
    // 简化的权限检查逻辑
    permissions := map[string]map[string][]string{
        "admin": {
            "users":   {"create", "read", "update", "delete"},
            "posts":   {"create", "read", "update", "delete"},
            "system":  {"read", "update"},
        },
        "editor": {
            "posts": {"create", "read", "update"},
            "users": {"read"},
        },
        "user": {
            "posts": {"read"},
            "users": {"read"},
        },
    }

    if rolePerms, exists := permissions[role]; exists {
        if resourcePerms, exists := rolePerms[resource]; exists {
            for _, perm := range resourcePerms {
                if perm == action {
                    return true
                }
            }
        }
    }

    return false
}

// GetUserPermissions 获取用户权限列表
func (s *PermissionService) GetUserPermissions(userID uint) (map[string][]string, error) {
    // 获取用户角色
    var user models.User
    if err := s.db.First(&user, userID).Error; err != nil {
        return nil, err
    }

    // 返回角色权限
    return s.getRolePermissions(user.Role), nil
}

// getRolePermissions 获取角色权限列表
func (s *PermissionService) getRolePermissions(role string) map[string][]string {
    permissions := map[string]map[string][]string{
        "admin": {
            "users":   {"create", "read", "update", "delete"},
            "posts":   {"create", "read", "update", "delete"},
            "system":  {"read", "update"},
        },
        "editor": {
            "posts": {"create", "read", "update"},
            "users": {"read"},
        },
        "user": {
            "posts": {"read"},
            "users": {"read"},
        },
    }

    return permissions[role]
}

// HasAnyPermission 检查用户是否有任一权限
func (s *PermissionService) HasAnyPermission(userID uint, resource string, actions []string) bool {
    for _, action := range actions {
        if s.CheckPermission(userID, resource, action) {
            return true
        }
    }
    return false
}

// HasAllPermissions 检查用户是否有所有权限
func (s *PermissionService) HasAllPermissions(userID uint, resource string, actions []string) bool {
    for _, action := range actions {
        if !s.CheckPermission(userID, resource, action) {
            return false
        }
    }
    return true
}
```

### 2. 权限中间件

```go
package middleware

import (
    "iris-cn-sample-project/services"
    
    "github.com/kataras/iris/v12"
)

// RequirePermission 权限验证中间件
func RequirePermission(resource, action string) iris.Handler {
    return func(ctx iris.Context) {
        // 获取用户ID
        userID := ctx.Values().GetUintDefault("user_id", 0)
        if userID == 0 {
            ctx.JSON(iris.Map{
                "code":    401,
                "message": "用户未认证",
            })
            ctx.StatusCode(iris.StatusUnauthorized)
            return
        }

        // 检查权限
        permissionService := services.NewPermissionService()
        if !permissionService.CheckPermission(userID, resource, action) {
            ctx.JSON(iris.Map{
                "code":    403,
                "message": "权限不足",
                "required": iris.Map{
                    "resource": resource,
                    "action":   action,
                },
            })
            ctx.StatusCode(iris.StatusForbidden)
            return
        }

        ctx.Next()
    }
}

// RequireAnyPermission 任一权限验证中间件
func RequireAnyPermission(resource string, actions []string) iris.Handler {
    return func(ctx iris.Context) {
        // 获取用户ID
        userID := ctx.Values().GetUintDefault("user_id", 0)
        if userID == 0 {
            ctx.JSON(iris.Map{
                "code":    401,
                "message": "用户未认证",
            })
            ctx.StatusCode(iris.StatusUnauthorized)
            return
        }

        // 检查权限
        permissionService := services.NewPermissionService()
        if !permissionService.HasAnyPermission(userID, resource, actions) {
            ctx.JSON(iris.Map{
                "code":    403,
                "message": "权限不足",
                "required": iris.Map{
                    "resource": resource,
                    "actions":  actions,
                },
            })
            ctx.StatusCode(iris.StatusForbidden)
            return
        }

        ctx.Next()
    }
}

// RequireAllPermissions 所有权限验证中间件
func RequireAllPermissions(resource string, actions []string) iris.Handler {
    return func(ctx iris.Context) {
        // 获取用户ID
        userID := ctx.Values().GetUintDefault("user_id", 0)
        if userID == 0 {
            ctx.JSON(iris.Map{
                "code":    401,
                "message": "用户未认证",
            })
            ctx.StatusCode(iris.StatusUnauthorized)
            return
        }

        // 检查权限
        permissionService := services.NewPermissionService()
        if !permissionService.HasAllPermissions(userID, resource, actions) {
            ctx.JSON(iris.Map{
                "code":    403,
                "message": "权限不足",
                "required": iris.Map{
                    "resource": resource,
                    "actions":  actions,
                },
            })
            ctx.StatusCode(iris.StatusForbidden)
            return
        }

        ctx.Next()
    }
}

// UserPermission 用户权限中间件（只能操作自己的资源）
func UserPermission(resourceIDParam string) iris.Handler {
    return func(ctx iris.Context) {
        // 获取当前用户ID
        currentUserID := ctx.Values().GetUintDefault("user_id", 0)
        if currentUserID == 0 {
            ctx.JSON(iris.Map{
                "code":    401,
                "message": "用户未认证",
            })
            ctx.StatusCode(iris.StatusUnauthorized)
            return
        }

        // 获取资源ID
        resourceID, err := ctx.Params().GetInt(resourceIDParam)
        if err != nil {
            ctx.JSON(iris.Map{
                "code":    400,
                "message": "无效的资源ID",
            })
            ctx.StatusCode(iris.StatusBadRequest)
            return
        }

        // 管理员可以访问所有资源
        role := ctx.Values().GetStringDefault("role", "")
        if role == "admin" {
            ctx.Next()
            return
        }

        // 检查是否是自己的资源
        if currentUserID != uint(resourceID) {
            ctx.JSON(iris.Map{
                "code":    403,
                "message": "只能操作自己的资源",
            })
            ctx.StatusCode(iris.StatusForbidden)
            return
        }

        ctx.Next()
    }
}
```

## 安全最佳实践

### 1. 密码安全

```go
package utils

import (
    "crypto/rand"
    "golang.org/x/crypto/bcrypt"
)

// HashPassword 哈希密码
func HashPassword(password string) (string, error) {
    // 使用 bcrypt 哈希密码
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    if err != nil {
        return "", err
    }
    return string(hashedPassword), nil
}

// VerifyPassword 验证密码
func VerifyPassword(password, hashedPassword string) bool {
    err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
    return err == nil
}

// GenerateRandomPassword 生成随机密码
func GenerateRandomPassword(length int) (string, error) {
    const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*"
    
    bytes := make([]byte, length)
    if _, err := rand.Read(bytes); err != nil {
        return "", err
    }
    
    for i, b := range bytes {
        bytes[i] = charset[b%byte(len(charset))]
    }
    
    return string(bytes), nil
}

// ValidatePasswordStrength 验证密码强度
func ValidatePasswordStrength(password string) []string {
    var errors []string
    
    if len(password) < 8 {
        errors = append(errors, "密码长度至少8位")
    }
    
    hasUpper := false
    hasLower := false
    hasNumber := false
    hasSpecial := false
    
    for _, char := range password {
        switch {
        case char >= 'A' && char <= 'Z':
            hasUpper = true
        case char >= 'a' && char <= 'z':
            hasLower = true
        case char >= '0' && char <= '9':
            hasNumber = true
        case strings.ContainsRune("!@#$%^&*()_+-=[]{}|;:,.<>?", char):
            hasSpecial = true
        }
    }
    
    if !hasUpper {
        errors = append(errors, "密码必须包含大写字母")
    }
    if !hasLower {
        errors = append(errors, "密码必须包含小写字母")
    }
    if !hasNumber {
        errors = append(errors, "密码必须包含数字")
    }
    if !hasSpecial {
        errors = append(errors, "密码必须包含特殊字符")
    }
    
    return errors
}
```

### 2. 会话管理

```go
package services

import (
    "crypto/rand"
    "encoding/hex"
    "fmt"
    "time"
    
    "iris-cn-sample-project/database"
    "iris-cn-sample-project/models"
    
    "gorm.io/gorm"
)

// SessionService 会话服务
type SessionService struct {
    db *gorm.DB
}

// NewSessionService 创建会话服务实例
func NewSessionService() *SessionService {
    return &SessionService{
        db: database.GetDB(),
    }
}

// CreateSession 创建会话
func (s *SessionService) CreateSession(userID uint) (*models.Session, error) {
    // 生成会话ID
    sessionID, err := s.generateSessionID()
    if err != nil {
        return nil, fmt.Errorf("生成会话ID失败: %v", err)
    }

    // 创建会话
    session := &models.Session{
        ID:        sessionID,
        UserID:    userID,
        ExpiresAt: time.Now().Add(24 * time.Hour), // 24小时过期
        CreatedAt: time.Now(),
    }

    if err := s.db.Create(session).Error; err != nil {
        return nil, fmt.Errorf("创建会话失败: %v", err)
    }

    return session, nil
}

// GetSession 获取会话
func (s *SessionService) GetSession(sessionID string) (*models.Session, error) {
    var session models.Session
    err := s.db.Where("id = ? AND expires_at > ?", sessionID, time.Now()).First(&session).Error
    if err != nil {
        return nil, err
    }
    return &session, nil
}

// DeleteSession 删除会话
func (s *SessionService) DeleteSession(sessionID string) error {
    return s.db.Where("id = ?", sessionID).Delete(&models.Session{}).Error
}

// DeleteUserSessions 删除用户所有会话
func (s *SessionService) DeleteUserSessions(userID uint) error {
    return s.db.Where("user_id = ?", userID).Delete(&models.Session{}).Error
}

// CleanupExpiredSessions 清理过期会话
func (s *SessionService) CleanupExpiredSessions() error {
    return s.db.Where("expires_at < ?", time.Now()).Delete(&models.Session{}).Error
}

// generateSessionID 生成会话ID
func (s *SessionService) generateSessionID() (string, error) {
    bytes := make([]byte, 32)
    if _, err := rand.Read(bytes); err != nil {
        return "", err
    }
    return hex.EncodeToString(bytes), nil
}
```

## 下一步

现在您已经掌握了身份验证的各种技巧，建议继续学习：

1. [错误处理](./10-错误处理.md) - 学习错误处理机制
2. [部署运维](./11-部署运维.md) - 学习应用部署
3. [性能优化](./12-性能优化.md) - 掌握性能调优

## 相关资源

- [JWT 官方规范](https://tools.ietf.org/html/rfc7519)
- [Go JWT 库](https://github.com/golang-jwt/jwt)
- [OWASP 认证备忘录](https://owasp.org/www-community/Authentication_Cheat_Sheet)