# 08 - 数据库集成

## 数据库集成概述

Iris 框架本身不包含数据库功能，但可以轻松集成各种数据库库。本项目使用 GORM 作为 ORM 框架，支持多种数据库类型，包括 MySQL、PostgreSQL、SQLite 等。

## GORM 配置

### 1. 基本配置

```go
package database

import (
    "fmt"
    "time"
    
    "iris-cn-sample-project/config"
    "iris-cn-sample-project/models"
    
    "gorm.io/driver/mysql"
    "gorm.io/driver/postgres"
    "gorm.io/driver/sqlite"
    "gorm.io/gorm"
    "gorm.io/gorm/logger"
)

var DB *gorm.DB

// InitDB 初始化数据库连接
func InitDB() error {
    cfg := config.GetConfig()
    
    // 配置日志级别
    logLevel := logger.Silent
    if cfg.Log.Level == "debug" {
        logLevel = logger.Info
    }
    
    var err error
    var dialector gorm.Dialector
    
    // 根据配置选择数据库驱动
    switch cfg.Database.Driver {
    case "mysql":
        dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&parseTime=True&loc=Local",
            cfg.Database.Username,
            cfg.Database.Password,
            cfg.Database.Host,
            cfg.Database.Port,
            cfg.Database.Database,
        )
        dialector = mysql.Open(dsn)
        
    case "postgres":
        dsn := fmt.Sprintf("host=%s user=%s password=%s dbname=%s port=%s sslmode=%s TimeZone=Asia/Shanghai",
            cfg.Database.Host,
            cfg.Database.Username,
            cfg.Database.Password,
            cfg.Database.Database,
            cfg.Database.Port,
            cfg.Database.SSL,
        )
        dialector = postgres.Open(dsn)
        
    case "sqlite":
        dialector = sqlite.Open(cfg.Database.Database)
        
    default:
        return fmt.Errorf("不支持的数据库驱动: %s", cfg.Database.Driver)
    }
    
    // 连接数据库
    DB, err = gorm.Open(dialector, &gorm.Config{
        Logger: logger.Default.LogMode(logLevel),
        NowFunc: func() time.Time {
            return time.Now().Local()
        },
        // 禁用外键约束（可选）
        DisableForeignKeyConstraintWhenMigrating: true,
        // 启用预编译
        PrepareStmt: true,
    })
    
    if err != nil {
        return fmt.Errorf("数据库连接失败: %v", err)
    }
    
    // 获取底层的 sql.DB 对象进行连接池配置
    sqlDB, err := DB.DB()
    if err != nil {
        return fmt.Errorf("获取数据库实例失败: %v", err)
    }
    
    // 设置连接池参数
    sqlDB.SetMaxIdleConns(10)                    // 设置空闲连接池中连接的最大数量
    sqlDB.SetMaxOpenConns(100)                   // 设置打开数据库连接的最大数量
    sqlDB.SetConnMaxLifetime(time.Hour)           // 设置连接可复用的最大时间
    
    return nil
}
```

### 2. 数据库迁移

```go
// AutoMigrate 自动迁移数据库表结构
func AutoMigrate() error {
    return DB.AutoMigrate(
        &models.User{},
        &models.Post{},
        &models.Comment{},
        &models.Tag{},
        &models.Category{},
    )
}

// CreateTables 创建数据库表
func CreateTables() error {
    // 手动创建表，可以更精确地控制表结构
    if err := DB.Migrator().CreateTable(&models.User{}); err != nil {
        return fmt.Errorf("创建用户表失败: %v", err)
    }
    
    if err := DB.Migrator().CreateTable(&models.Post{}); err != nil {
        return fmt.Errorf("创建文章表失败: %v", err)
    }
    
    // 创建索引
    if err := createIndexes(); err != nil {
        return fmt.Errorf("创建索引失败: %v", err)
    }
    
    return nil
}

// createIndexes 创建数据库索引
func createIndexes() error {
    // 用户表索引
    if err := DB.Exec("CREATE INDEX IF NOT EXISTS idx_users_email ON users(email)").Error; err != nil {
        return err
    }
    if err := DB.Exec("CREATE INDEX IF NOT EXISTS idx_users_username ON users(username)").Error; err != nil {
        return err
    }
    if err := DB.Exec("CREATE INDEX IF NOT EXISTS idx_users_status ON users(status)").Error; err != nil {
        return err
    }
    
    // 文章表索引
    if err := DB.Exec("CREATE INDEX IF NOT EXISTS idx_posts_author_id ON posts(author_id)").Error; err != nil {
        return err
    }
    if err := DB.Exec("CREATE INDEX IF NOT EXISTS idx_posts_status ON posts(status)").Error; err != nil {
        return err
    }
    if err := DB.Exec("CREATE INDEX IF NOT EXISTS idx_posts_created_at ON posts(created_at)").Error; err != nil {
        return err
    }
    
    return nil
}
```

## 模型定义

### 1. 基本模型

```go
package models

import (
    "time"
    "gorm.io/gorm"
)

// BaseModel 基础模型
type BaseModel struct {
    ID        uint           `json:"id" gorm:"primaryKey"`
    CreatedAt time.Time      `json:"created_at" gorm:"autoCreateTime"`
    UpdatedAt time.Time      `json:"updated_at" gorm:"autoUpdateTime"`
    DeletedAt gorm.DeletedAt `json:"-" gorm:"index"`
}

// User 用户模型
type User struct {
    BaseModel
    Username  string     `json:"username" gorm:"uniqueIndex;not null;size:50" validate:"required,min=3,max=50"`
    Email     string     `json:"email" gorm:"uniqueIndex;not null;size:100" validate:"required,email"`
    Password  string     `json:"-" gorm:"not null;size:255"`
    FirstName string     `json:"first_name" gorm:"size:50"`
    LastName  string     `json:"last_name" gorm:"size:50"`
    Avatar    string     `json:"avatar" gorm:"size:255"`
    Role      string     `json:"role" gorm:"default:user;size:20"`
    Status    string     `json:"status" gorm:"default:active;size:20"`
    LastLogin *time.Time `json:"last_login"`
    
    // 关联关系
    Posts    []Post    `json:"posts,omitempty" gorm:"foreignKey:AuthorID"`
    Comments []Comment `json:"comments,omitempty" gorm:"foreignKey:UserID"`
    
    // 自定义方法
}

// Post 文章模型
type Post struct {
    BaseModel
    Title       string    `json:"title" gorm:"not null;size:200" validate:"required,max=200"`
    Content     string    `json:"content" gorm:"type:text"`
    Excerpt     string    `json:"excerpt" gorm:"size:500"`
    Slug        string    `json:"slug" gorm:"uniqueIndex;size:200"`
    Status      string    `json:"status" gorm:"default:draft;size:20"`
    Type        string    `json:"type" gorm:"default:post;size:20"`
    Featured    bool      `json:"featured" gorm:"default:false"`
    Views       int       `json:"views" gorm:"default:0"`
    Likes       int       `json:"likes" gorm:"default:0"`
    PublishedAt *time.Time `json:"published_at"`
    
    // 外键
    AuthorID   uint      `json:"author_id" gorm:"not null;index"`
    CategoryID *uint     `json:"category_id" gorm:"index"`
    
    // 关联关系
    Author    User      `json:"author" gorm:"foreignKey:AuthorID"`
    Category  *Category `json:"category,omitempty" gorm:"foreignKey:CategoryID"`
    Tags      []Tag     `json:"tags,omitempty" gorm:"many2many:post_tags;"`
    Comments  []Comment `json:"comments,omitempty" gorm:"foreignKey:PostID"`
}

// Comment 评论模型
type Comment struct {
    BaseModel
    Content string `json:"content" gorm:"type:text;not null" validate:"required"`
    Status  string `json:"status" gorm:"default:approved;size:20"`
    IP      string `json:"ip" gorm:"size:45"`
    UserAgent string `json:"user_agent" gorm:"size:500"`
    
    // 外键
    UserID uint `json:"user_id" gorm:"not null;index"`
    PostID uint `json:"post_id" gorm:"not null;index"`
    ParentID *uint `json:"parent_id" gorm:"index"`
    
    // 关联关系
    User     User      `json:"user" gorm:"foreignKey:UserID"`
    Post     Post      `json:"post" gorm:"foreignKey:PostID"`
    Parent   *Comment  `json:"parent,omitempty" gorm:"foreignKey:ParentID"`
    Replies  []Comment `json:"replies,omitempty" gorm:"foreignKey:ParentID"`
}

// Tag 标签模型
type Tag struct {
    BaseModel
    Name        string `json:"name" gorm:"uniqueIndex;not null;size:50" validate:"required,max=50"`
    Slug        string `json:"slug" gorm:"uniqueIndex;size:50"`
    Description string `json:"description" gorm:"size:500"`
    Color       string `json:"color" gorm:"size:7"`
    
    // 关联关系
    Posts []Post `json:"posts,omitempty" gorm:"many2many:post_tags;"`
}

// Category 分类模型
type Category struct {
    BaseModel
    Name        string     `json:"name" gorm:"uniqueIndex;not null;size:50" validate:"required,max=50"`
    Slug        string     `json:"slug" gorm:"uniqueIndex;size:50"`
    Description string     `json:"description" gorm:"size:500"`
    ParentID    *uint      `json:"parent_id" gorm:"index"`
    Sort        int        `json:"sort" gorm:"default:0"`
    Status      string     `json:"status" gorm:"default:active;size:20"`
    
    // 关联关系
    Parent   *Category `json:"parent,omitempty" gorm:"foreignKey:ParentID"`
    Children []Category `json:"children,omitempty" gorm:"foreignKey:ParentID"`
    Posts    []Post     `json:"posts,omitempty" gorm:"foreignKey:CategoryID"`
}
```

### 2. 模型钩子

```go
// BeforeCreate 创建前的钩子
func (u *User) BeforeCreate(tx *gorm.DB) error {
    // 加密密码
    if u.Password != "" {
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(u.Password), bcrypt.DefaultCost)
        if err != nil {
            return fmt.Errorf("密码加密失败: %v", err)
        }
        u.Password = string(hashedPassword)
    }
    
    // 生成用户名 slug
    if u.Username != "" {
        u.Username = generateSlug(u.Username)
    }
    
    return nil
}

// BeforeUpdate 更新前的钩子
func (u *User) BeforeUpdate(tx *gorm.DB) error {
    // 如果密码被修改，重新加密
    if u.Password != "" {
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(u.Password), bcrypt.DefaultCost)
        if err != nil {
            return fmt.Errorf("密码加密失败: %v", err)
        }
        u.Password = string(hashedPassword)
    }
    
    return nil
}

// AfterFind 查询后的钩子
func (u *User) AfterFind(tx *gorm.DB) error {
    // 隐藏敏感信息
    u.Password = ""
    return nil
}

// BeforeDelete 删除前的钩子
func (u *User) BeforeDelete(tx *gorm.DB) error {
    // 检查是否可以删除
    if u.Role == "admin" {
        // 检查是否还有其他管理员
        var count int64
        if err := tx.Model(&User{}).Where("role = ? AND id != ?", "admin", u.ID).Count(&count).Error; err != nil {
            return err
        }
        if count == 0 {
            return fmt.Errorf("不能删除最后一个管理员")
        }
    }
    
    return nil
}

// Post 模型的钩子
func (p *Post) BeforeCreate(tx *gorm.DB) error {
    // 生成 slug
    if p.Slug == "" {
        p.Slug = generateSlug(p.Title)
    }
    
    // 设置发布时间
    if p.Status == "published" && p.PublishedAt == nil {
        now := time.Now()
        p.PublishedAt = &now
    }
    
    return nil
}

func (p *Post) BeforeUpdate(tx *gorm.DB) error {
    // 当状态变为发布时，设置发布时间
    if p.Status == "published" && p.PublishedAt == nil {
        now := time.Now()
        p.PublishedAt = &now
    }
    
    return nil
}
```

## 数据库操作

### 1. 基本CRUD操作

```go
package services

import (
    "fmt"
    "strings"
    "time"
    
    "iris-cn-sample-project/database"
    "iris-cn-sample-project/models"
    
    "gorm.io/gorm"
)

// UserService 用户服务
type UserService struct {
    db *gorm.DB
}

// NewUserService 创建用户服务实例
func NewUserService() *UserService {
    return &UserService{
        db: database.GetDB(),
    }
}

// Create 创建用户
func (s *UserService) Create(user *models.User) error {
    return s.db.Create(user).Error
}

// GetByID 根据ID获取用户
func (s *UserService) GetByID(id uint) (*models.User, error) {
    var user models.User
    err := s.db.First(&user, id).Error
    if err != nil {
        return nil, err
    }
    return &user, nil
}

// GetByUsername 根据用户名获取用户
func (s *UserService) GetByUsername(username string) (*models.User, error) {
    var user models.User
    err := s.db.Where("username = ?", username).First(&user).Error
    if err != nil {
        return nil, err
    }
    return &user, nil
}

// GetByEmail 根据邮箱获取用户
func (s *UserService) GetByEmail(email string) (*models.User, error) {
    var user models.User
    err := s.db.Where("email = ?", email).First(&user).Error
    if err != nil {
        return nil, err
    }
    return &user, nil
}

// Update 更新用户
func (s *UserService) Update(user *models.User) error {
    return s.db.Save(user).Error
}

// Delete 删除用户（软删除）
func (s *UserService) Delete(id uint) error {
    return s.db.Delete(&models.User{}, id).Error
}

// HardDelete 硬删除用户
func (s *UserService) HardDelete(id uint) error {
    return s.db.Unscoped().Delete(&models.User{}, id).Error
}

// List 获取用户列表
func (s *UserService) List(page, pageSize int, filters map[string]interface{}) ([]*models.User, int64, error) {
    var users []*models.User
    var total int64
    
    query := s.db.Model(&models.User{})
    
    // 应用过滤条件
    if status, ok := filters["status"]; ok {
        query = query.Where("status = ?", status)
    }
    if role, ok := filters["role"]; ok {
        query = query.Where("role = ?", role)
    }
    if keyword, ok := filters["keyword"]; ok && keyword != "" {
        query = query.Where("username LIKE ? OR email LIKE ? OR first_name LIKE ? OR last_name LIKE ?",
            "%"+keyword.(string)+"%", "%"+keyword.(string)+"%", "%"+keyword.(string)+"%", "%"+keyword.(string)+"%")
    }
    
    // 获取总数
    if err := query.Count(&total).Error; err != nil {
        return nil, 0, err
    }
    
    // 分页查询
    offset := (page - 1) * pageSize
    err := query.Offset(offset).Limit(pageSize).Order("created_at DESC").Find(&users).Error
    if err != nil {
        return nil, 0, err
    }
    
    return users, total, nil
}
```

### 2. 复杂查询

```go
// PostService 文章服务
type PostService struct {
    db *gorm.DB
}

// NewPostService 创建文章服务实例
func NewPostService() *PostService {
    return &PostService{
        db: database.GetDB(),
    }
}

// GetPublishedPosts 获取已发布的文章
func (s *PostService) GetPublishedPosts(page, pageSize int) ([]*models.Post, int64, error) {
    var posts []*models.Post
    var total int64
    
    query := s.db.Model(&models.Post{}).
        Preload("Author").
        Preload("Category").
        Preload("Tags").
        Where("status = ? AND published_at <= ?", "published", time.Now())
    
    // 获取总数
    if err := query.Count(&total).Error; err != nil {
        return nil, 0, err
    }
    
    // 分页查询
    offset := (page - 1) * pageSize
    err := query.Offset(offset).
        Limit(pageSize).
        Order("published_at DESC").
        Find(&posts).Error
    
    if err != nil {
        return nil, 0, err
    }
    
    return posts, total, nil
}

// GetPostsByCategory 根据分类获取文章
func (s *PostService) GetPostsByCategory(categoryID uint, page, pageSize int) ([]*models.Post, int64, error) {
    var posts []*models.Post
    var total int64
    
    query := s.db.Model(&models.Post{}).
        Preload("Author").
        Preload("Category").
        Preload("Tags").
        Where("status = ? AND category_id = ? AND published_at <= ?", 
            "published", categoryID, time.Now())
    
    // 获取总数
    if err := query.Count(&total).Error; err != nil {
        return nil, 0, err
    }
    
    // 分页查询
    offset := (page - 1) * pageSize
    err := query.Offset(offset).
        Limit(pageSize).
        Order("published_at DESC").
        Find(&posts).Error
    
    if err != nil {
        return nil, 0, err
    }
    
    return posts, total, nil
}

// GetPostsByTag 根据标签获取文章
func (s *PostService) GetPostsByTag(tagID uint, page, pageSize int) ([]*models.Post, int64, error) {
    var posts []*models.Post
    var total int64
    
    query := s.db.Model(&models.Post{}).
        Preload("Author").
        Preload("Category").
        Preload("Tags").
        Joins("INNER JOIN post_tags ON posts.id = post_tags.post_id").
        Where("posts.status = ? AND post_tags.tag_id = ? AND posts.published_at <= ?", 
            "published", tagID, time.Now())
    
    // 获取总数
    if err := query.Count(&total).Error; err != nil {
        return nil, 0, err
    }
    
    // 分页查询
    offset := (page - 1) * pageSize
    err := query.Offset(offset).
        Limit(pageSize).
        Order("posts.published_at DESC").
        Find(&posts).Error
    
    if err != nil {
        return nil, 0, err
    }
    
    return posts, total, nil
}

// SearchPosts 搜索文章
func (s *PostService) SearchPosts(keyword string, page, pageSize int) ([]*models.Post, int64, error) {
    var posts []*models.Post
    var total int64
    
    query := s.db.Model(&models.Post{}).
        Preload("Author").
        Preload("Category").
        Preload("Tags").
        Where("status = ? AND published_at <= ? AND (title LIKE ? OR content LIKE ?)", 
            "published", time.Now(), "%"+keyword+"%", "%"+keyword+"%")
    
    // 获取总数
    if err := query.Count(&total).Error; err != nil {
        return nil, 0, err
    }
    
    // 分页查询
    offset := (page - 1) * pageSize
    err := query.Offset(offset).
        Limit(pageSize).
        Order("published_at DESC").
        Find(&posts).Error
    
    if err != nil {
        return nil, 0, err
    }
    
    return posts, total, nil
}

// GetPopularPosts 获取热门文章
func (s *PostService) GetPopularPosts(limit int) ([]*models.Post, error) {
    var posts []*models.Post
    
    err := s.db.Model(&models.Post{}).
        Preload("Author").
        Preload("Category").
        Preload("Tags").
        Where("status = ? AND published_at <= ?", "published", time.Now()).
        Order("views DESC, likes DESC").
        Limit(limit).
        Find(&posts).Error
    
    return posts, err
}

// GetRecentPosts 获取最新文章
func (s *PostService) GetRecentPosts(limit int) ([]*models.Post, error) {
    var posts []*models.Post
    
    err := s.db.Model(&models.Post{}).
        Preload("Author").
        Preload("Category").
        Preload("Tags").
        Where("status = ? AND published_at <= ?", "published", time.Now()).
        Order("published_at DESC").
        Limit(limit).
        Find(&posts).Error
    
    return posts, err
}
```

### 3. 事务处理

```go
// TransactionService 事务服务示例
type TransactionService struct {
    db *gorm.DB
}

// NewTransactionService 创建事务服务实例
func NewTransactionService() *TransactionService {
    return &TransactionService{
        db: database.GetDB(),
    }
}

// CreateUserWithProfile 创建用户和个人资料（事务示例）
func (s *TransactionService) CreateUserWithProfile(user *models.User, profile *models.UserProfile) error {
    return s.db.Transaction(func(tx *gorm.DB) error {
        // 创建用户
        if err := tx.Create(user).Error; err != nil {
            return fmt.Errorf("创建用户失败: %v", err)
        }
        
        // 设置个人资料的用户ID
        profile.UserID = user.ID
        
        // 创建个人资料
        if err := tx.Create(profile).Error; err != nil {
            return fmt.Errorf("创建个人资料失败: %v", err)
        }
        
        // 创建默认设置
        settings := &models.UserSettings{
            UserID: user.ID,
            Theme:  "light",
            Lang:   "zh-CN",
        }
        if err := tx.Create(settings).Error; err != nil {
            return fmt.Errorf("创建用户设置失败: %v", err)
        }
        
        return nil
    })
}

// TransferPoints 用户积分转移（事务示例）
func (s *TransactionService) TransferPoints(fromUserID, toUserID uint, points int, reason string) error {
    return s.db.Transaction(func(tx *gorm.DB) error {
        // 检查发送者积分
        var fromUser models.User
        if err := tx.First(&fromUser, fromUserID).Error; err != nil {
            return fmt.Errorf("发送者不存在: %v", err)
        }
        
        if fromUser.Points < points {
            return fmt.Errorf("积分不足")
        }
        
        // 检查接收者
        var toUser models.User
        if err := tx.First(&toUser, toUserID).Error; err != nil {
            return fmt.Errorf("接收者不存在: %v", err)
        }
        
        // 扣除发送者积分
        if err := tx.Model(&fromUser).Update("points", gorm.Expr("points - ?", points)).Error; err != nil {
            return fmt.Errorf("扣除积分失败: %v", err)
        }
        
        // 增加接收者积分
        if err := tx.Model(&toUser).Update("points", gorm.Expr("points + ?", points)).Error; err != nil {
            return fmt.Errorf("增加积分失败: %v", err)
        }
        
        // 创建积分记录
        record := &models.PointRecord{
            FromUserID: fromUserID,
            ToUserID:   toUserID,
            Points:     points,
            Reason:     reason,
            Status:     "completed",
        }
        if err := tx.Create(record).Error; err != nil {
            return fmt.Errorf("创建积分记录失败: %v", err)
        }
        
        return nil
    })
}

// BatchCreatePosts 批量创建文章（事务示例）
func (s *TransactionService) BatchCreatePosts(posts []*models.Post) error {
    return s.db.Transaction(func(tx *gorm.DB) error {
        for i, post := range posts {
            // 设置文章序号
            post.Sort = i + 1
            
            // 创建文章
            if err := tx.Create(post).Error; err != nil {
                return fmt.Errorf("创建第%d篇文章失败: %v", i+1, err)
            }
            
            // 如果有标签，创建标签关联
            if len(post.Tags) > 0 {
                for _, tag := range post.Tags {
                    // 检查标签是否存在
                    var existingTag models.Tag
                    err := tx.Where("name = ?", tag.Name).First(&existingTag).Error
                    if err != nil {
                        if err == gorm.ErrRecordNotFound {
                            // 创建新标签
                            if err := tx.Create(&tag).Error; err != nil {
                                return fmt.Errorf("创建标签失败: %v", err)
                            }
                            existingTag = tag
                        } else {
                            return fmt.Errorf("查询标签失败: %v", err)
                        }
                    }
                    
                    // 创建文章标签关联
                    postTag := &models.PostTag{
                        PostID: post.ID,
                        TagID:  existingTag.ID,
                    }
                    if err := tx.Create(postTag).Error; err != nil {
                        return fmt.Errorf("创建文章标签关联失败: %v", err)
                    }
                }
            }
        }
        
        return nil
    })
}
```

## 数据库优化

### 1. 索引优化

```go
// IndexOptimizer 索引优化器
type IndexOptimizer struct {
    db *gorm.DB
}

// NewIndexOptimizer 创建索引优化器
func NewIndexOptimizer() *IndexOptimizer {
    return &IndexOptimizer{
        db: database.GetDB(),
    }
}

// OptimizeIndexes 优化索引
func (o *IndexOptimizer) OptimizeIndexes() error {
    // 分析查询性能
    queries := []string{
        "EXPLAIN ANALYZE SELECT * FROM users WHERE email = ?",
        "EXPLAIN ANALYZE SELECT * FROM posts WHERE status = ? AND published_at <= ? ORDER BY published_at DESC",
        "EXPLAIN ANALYZE SELECT * FROM posts WHERE author_id = ? ORDER BY created_at DESC",
        "EXPLAIN ANALYZE SELECT * FROM comments WHERE post_id = ? AND status = ? ORDER BY created_at DESC",
    }
    
    for _, query := range queries {
        var result []map[string]interface{}
        if err := o.db.Raw(query).Scan(&result).Error; err != nil {
            return fmt.Errorf("分析查询失败: %v", err)
        }
        
        // 分析结果并建议索引
        o.analyzeQueryPlan(result)
    }
    
    return nil
}

// CreateRecommendedIndexes 创建推荐的索引
func (o *IndexOptimizer) CreateRecommendedIndexes() error {
    indexes := []struct {
        name   string
        query  string
        reason string
    }{
        {
            name:   "idx_users_email_status",
            query:  "CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_users_email_status ON users(email, status)",
            reason: "用户登录查询优化",
        },
        {
            name:   "idx_posts_status_published_at",
            query:  "CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_posts_status_published_at ON posts(status, published_at DESC)",
            reason: "文章列表查询优化",
        },
        {
            name:   "idx_posts_author_status_published",
            query:  "CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_posts_author_status_published ON posts(author_id, status, published_at DESC)",
            reason: "用户文章查询优化",
        },
        {
            name:   "idx_comments_post_status",
            query:  "CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_comments_post_status ON comments(post_id, status, created_at DESC)",
            reason: "文章评论查询优化",
        },
        {
            name:   "idx_post_tags_post_tag",
            query:  "CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_post_tags_post_tag ON post_tags(post_id, tag_id)",
            reason: "标签文章关联查询优化",
        },
    }
    
    for _, index := range indexes {
        fmt.Printf("创建索引: %s (%s)\n", index.name, index.reason)
        if err := o.db.Exec(index.query).Error; err != nil {
            fmt.Printf("创建索引失败: %s, 错误: %v\n", index.name, err)
        }
    }
    
    return nil
}
```

### 2. 查询优化

```go
// QueryOptimizer 查询优化器
type QueryOptimizer struct {
    db *gorm.DB
}

// NewQueryOptimizer 创建查询优化器
func NewQueryOptimizer() *QueryOptimizer {
    return &QueryOptimizer{
        db: database.GetDB(),
    }
}

// OptimizedUserList 优化的用户列表查询
func (o *QueryOptimizer) OptimizedUserList(page, pageSize int) ([]*models.User, int64, error) {
    var users []*models.User
    var total int64
    
    // 使用索引优化查询
    query := o.db.Model(&models.User{}).
        Select("id, username, email, first_name, last_name, avatar, role, status, created_at").
        Where("status = ?", "active")
    
    // 获取总数（使用覆盖索引）
    if err := query.Count(&total).Error; err != nil {
        return nil, 0, err
    }
    
    // 分页查询
    offset := (page - 1) * pageSize
    err := query.Offset(offset).
        Limit(pageSize).
        Order("created_at DESC").
        Find(&users).Error
    
    return users, total, err
}

// OptimizedPostList 优化的文章列表查询
func (o *QueryOptimizer) OptimizedPostList(page, pageSize int) ([]*models.Post, int64, error) {
    var posts []*models.Post
    var total int64
    
    // 使用子查询优化
    query := o.db.Table("posts").
        Select("posts.*, authors.username as author_name, authors.avatar as author_avatar").
        Joins("LEFT JOIN users authors ON posts.author_id = authors.id").
        Where("posts.status = ? AND posts.published_at <= ?", "published", time.Now())
    
    // 获取总数
    if err := query.Count(&total).Error; err != nil {
        return nil, 0, err
    }
    
    // 分页查询
    offset := (page - 1) * pageSize
    err := query.Offset(offset).
        Limit(pageSize).
        Order("posts.published_at DESC").
        Find(&posts).Error
    
    return posts, total, err
}

// BatchInsert 批量插入优化
func (o *QueryOptimizer) BatchInsert(records interface{}, batchSize int) error {
    return o.db.Transaction(func(tx *gorm.DB) error {
        // 使用批量插入
        if err := tx.CreateInBatches(records, batchSize).Error; err != nil {
            return err
        }
        
        return nil
    })
}
```

## 数据库监控

### 1. 性能监控

```go
// DatabaseMonitor 数据库监控器
type DatabaseMonitor struct {
    db *gorm.DB
}

// NewDatabaseMonitor 创建数据库监控器
func NewDatabaseMonitor() *DatabaseMonitor {
    return &DatabaseMonitor{
        db: database.GetDB(),
    }
}

// GetDatabaseStats 获取数据库统计信息
func (m *DatabaseMonitor) GetDatabaseStats() (map[string]interface{}, error) {
    stats := make(map[string]interface{})
    
    // 获取连接池状态
    sqlDB, err := m.db.DB()
    if err != nil {
        return nil, err
    }
    
    dbStats := sqlDB.Stats()
    stats["connection_pool"] = map[string]interface{}{
        "open_connections":     dbStats.OpenConnections,
        "in_use":              dbStats.InUse,
        "idle":                dbStats.Idle,
        "wait_count":          dbStats.WaitCount,
        "wait_duration":       dbStats.WaitDuration.String(),
        "max_idle_closed":      dbStats.MaxIdleClosed,
        "max_idle_time_closed": dbStats.MaxIdleTimeClosed,
        "max_lifetime_closed":  dbStats.MaxLifetimeClosed,
    }
    
    // 获取表统计信息
    tableStats, err := m.getTableStats()
    if err == nil {
        stats["tables"] = tableStats
    }
    
    // 获取慢查询统计
    slowQueries, err := m.getSlowQueries()
    if err == nil {
        stats["slow_queries"] = slowQueries
    }
    
    return stats, nil
}

// getTableStats 获取表统计信息
func (m *DatabaseMonitor) getTableStats() (map[string]interface{}, error) {
    tableStats := make(map[string]interface{})
    
    tables := []string{"users", "posts", "comments", "tags", "categories"}
    
    for _, table := range tables {
        var count int64
        if err := m.db.Table(table).Count(&count).Error; err == nil {
            tableStats[table] = map[string]interface{}{
                "count": count,
            }
        }
    }
    
    return tableStats, nil
}

// getSlowQueries 获取慢查询统计
func (m *DatabaseMonitor) getSlowQueries() ([]map[string]interface{}, error) {
    // 这里可以根据不同的数据库实现慢查询统计
    // 以下是示例实现
    var slowQueries []map[string]interface{}
    
    // MySQL 慢查询
    if m.db.Dialector.Name() == "mysql" {
        var results []struct {
            QueryTime float64 `json:"query_time"`
            LockTime  float64 `json:"lock_time"`
            RowsSent  int     `json:"rows_sent"`
            RowsExamined int  `json:"rows_examined"`
            SQLText   string  `json:"sql_text"`
        }
        
        if err := m.db.Raw("SHOW FULL PROCESSLIST").Scan(&results).Error; err == nil {
            for _, result := range results {
                if result.QueryTime > 2.0 { // 超过2秒的查询
                    slowQueries = append(slowQueries, map[string]interface{}{
                        "query_time":    result.QueryTime,
                        "lock_time":     result.LockTime,
                        "rows_sent":     result.RowsSent,
                        "rows_examined": result.RowsExamined,
                        "sql_text":      result.SQLText,
                    })
                }
            }
        }
    }
    
    return slowQueries, nil
}
```

## 最佳实践

### 1. 数据库设计原则

- 合理设计表结构，避免冗余
- 为常用查询字段创建索引
- 使用外键约束保证数据完整性
- 定期备份重要数据
- 监控数据库性能

### 2. 查询优化建议

- 使用预编译语句防止SQL注入
- 避免在循环中执行数据库查询
- 使用批量操作提高性能
- 合理使用分页查询
- 避免SELECT *，只查询需要的字段

### 3. 事务使用原则

- 保持事务简短，避免长时间锁定
- 只在必要时使用事务
- 处理好事务异常和回滚
- 避免嵌套事务

## 下一步

现在您已经掌握了数据库集成的各种技巧，建议继续学习：

1. [身份验证](./09-身份验证.md) - 掌握认证授权
2. [错误处理](./10-错误处理.md) - 学习错误处理机制
3. [部署运维](./11-部署运维.md) - 学习应用部署

## 相关资源

- [GORM 官方文档](https://gorm.io/docs/)
- [Iris 数据库集成](https://iris-go.com/database)
- [数据库性能优化](https://www.postgresql.org/docs/current/performance-tips.html)